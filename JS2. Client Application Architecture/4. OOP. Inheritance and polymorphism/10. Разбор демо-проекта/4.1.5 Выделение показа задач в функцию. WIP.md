# 4.1.5 Рефакторинг: Выделение показа задач в функцию

- Цель рефакторинга — улучшение структуры кода для повышения его читаемости и удобства сопровождения
- В данном случае акцент будет сделан на вынесении логики отображения задач в отдельную функцию, что упростит поддержку и расширение функционала в будущем

## Проблема текущего состояния метода init()

- Метод init() сейчас отвечает за инициализацию презентера и включает логику рендеринга всех элементов, включая задачи
- Несмотря на то, что метод кажется простым и читаемым, его текущая структура не масштабируется
- Например, когда потребуется перерисовать отдельные компоненты, а не весь набор элементов, текущий подход окажется неэффективным
- Поэтому имеет смысл вынести логику рендеринга задач в отдельную функцию

## Зачем выносить рендеринг задач в отдельный метод?

- **Масштабируемость**: Метод init() инициализирует презентер, а не должен отвечать за рендеринг задач. Отделив функциональность рендеринга, код станет более модульным и легче изменяемым

- **Чистота** кода: Если всё останется в init(), то при добавлении новой логики этот метод будет разрастаться, ухудшая читаемость

- **Гибкость**: Отдельный метод рендеринга задач позволит переиспользовать его для динамической перерисовки задач в процессе работы приложения, когда, например, данные обновляются частично

## Вынесение логики рендеринга задач

- Для начала выделим отдельную функцию, которая займётся отрисовкой всех задач. Назовём её renderTasks()
- Эта функция будет управлять процессом рендеринга задач, вместо того чтобы оставлять всю эту работу в init()

```js
class Presenter {
  // ...
  init() {
    // ...
    this.#renderTasks();
    // ...
  }

  #renderTasks() {
    for (let i = 0; i < this.#boardTasks.length; i++) {
      this.#renderTask(this.#boardTasks[i]);
    }
  }
}
```

- Теперь в методе init() остается только вызов метода renderTasks(), а вся основная логика отрисовки вынесена в отдельную функцию

## Создание метода для рендеринга одной задачи

- Следующий шаг — это создание метода renderTask(), который будет отвечать за рендеринг отдельной задачи
- Он будет приватным (так как используется только внутри презентера) и работать с каждым отдельным элементом списка задач

```js
class Presenter {
  // ...
  #renderTasks() {
    for (let i = 0; i < this.#boardTasks.length; i++) {
      this.#renderTask(this.#boardTasks[i]);
    }
  }

  #renderTask(task) {
    const taskComponent = new TaskView({ task });
    render(taskComponent, this.#taskListComponent.element);
  }
}
```

- Теперь метод renderTasks() использует цикл для обхода всех задач и передаёт каждую из них в renderTask(), которая отвечает за создание экземпляра представления задачи (TaskView) и его рендеринг

## Преимущества такого подхода

- **Локализация изменений**: Если в будущем изменится логика отрисовки задачи (например, нужно будет добавить какие-то дополнительные элементы), эти изменения можно будет внести только в метод renderTask(), не затрагивая метод init()

- **Упрощение поддержки**: Код становится более очевидным и проще для поддержки, поскольку задачи рендерятся в строго определённом месте

- **Повышенная читаемость**: Логика метода init() остаётся чистой и короткой, сосредотачивая в себе только общие действия по инициализации.
