# Обновление объектов в состоянии

- Состояние в React может содержать любые значения JavaScript, включая объекты
- Однако вы не должны изменять объекты, которые хранятся в состоянии, напрямую
- Вместо этого, при обновлении объекта необходимо создать новый объект (или сделать копию существующего), а затем обновить состояние, используя эту копию

```jsx
const [x, setX] = useState(0);
```

- До этого вы работали с числами, строками и логическими значениями
- Эти типы данных в JavaScript являются "неизменяемыми" (immutable), что означает, что их нельзя изменить напрямую
- Например, вы можете заменить значение, вызвав `setX`:

```jsx
setX(5);
```

- Здесь состояние x изменилось с 0 на 5, но само число 0 осталось неизменным
- Изменять встроенные примитивные значения, такие как числа, строки и логические значения, в JavaScript невозможно

- Теперь рассмотрим объект в состоянии:

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

- Технически вы можете изменить содержимое объекта, например:

```jsx
position.x = 5;
```

- Однако, хотя объекты в состоянии React технически изменяемы, вы должны относиться к ним так, как если бы они были неизменяемыми
- Вместо изменения объекта его всегда нужно заменять новым

## Считайте состояние неизменяемым

- Иными словами, любые объекты, которые вы сохраняете в состоянии, следует считать только для чтения

- Вот пример, где объект в состоянии представляет текущую позицию курсора
- Красная точка должна перемещаться, когда вы касаетесь или наводите курсор на область предварительного просмотра
- Однако точка остаётся в начальной позиции:

```jsx
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  return (
    <div
      onPointerMove={(e) => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}
    >
      <div
        style={{
          position: 'absolute',
          backgroundColor: 'red',
          borderRadius: '50%',
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

- Проблема в этом коде
- Вот часть кода, которая вызывает проблему:

```jsx
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}
```

- Эта часть кода изменяет объект `position` из предыдущего рендера
- Однако React не знает, что объект изменился, так как функция `setPosition` не была вызвана
- В результате React не обновляет интерфейс.

- Для решения этой проблемы нужно создать новый объект и передать его в функцию `setPosition`:

```jsx
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

- Теперь React получает указание заменить объект position новым, и компонент рендерится заново

## Локальная мутация допустима

- Мутация объекта — это проблема, когда изменяется объект, который уже находится в состоянии
- Однако мутация нового объекта, который только что был создан, является нормальной практикой:

```jsx
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
```

Этот код эквивалентен следующему:

```jsx
setPosition({
  x: e.clientX,
  y: e.clientY,
});
```

## Копирование объектов с помощью синтаксиса spread (...)

- В большинстве случаев вы захотите обновить только одну часть объекта, сохранив остальные данные
- Вместо ручного копирования всех полей, можно использовать синтаксис `...`:

```jsx
setPerson({
  ...person, // Копируем существующие поля
  firstName: e.target.value, // Перезаписываем нужное поле
});
```

- Теперь весь объект обновлён корректно

## Обновление вложенного объекта

- Если объект во внутреннем состоянии вложен, например:

```jsx
const [person, setPerson] = useState({
  name: 'Niki',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
  },
});
```

- Для обновления `person.artwork.city` нужно создать новый объект `artwork`, а затем новый объект `person`:

```jsx
setPerson({
  ...person,
  artwork: {
    ...person.artwork,
    city: 'New Delhi',
  },
});
```

## Использование Immer для упрощения

- Если состояние сложное, можно использовать библиотеку `Immer`
- Она позволяет писать код с использованием "мутирующего" синтаксиса, но при этом сама создаёт копии:

```jsx
import { useImmer } from 'use-immer';

updatePerson((draft) => {
  draft.artwork.city = 'Lagos';
});
```

- Immer значительно сокращает код, избегая необходимости явно копировать объекты вручную

## Почему нельзя изменять состояние в React?

- Удобство отладки: Логи остаются неизменными, что упрощает отслеживание изменений состояния
- Оптимизации: React быстрее сравнивает объекты, если они неизменяемы
- Новые возможности React: Некоторые будущие функции требуют, чтобы состояние оставалось неизменяемым
- Лёгкость реализации: Например, функции Undo/Redo проще внедрить, если состояние не изменяется

## Итоги

- Всегда относитесь к состоянию как к неизменяемому
- Не изменяйте объекты напрямую; создавайте новые
- Используйте синтаксис ... для копирования объектов
- Для работы с вложенными объектами рассмотрите использование Immer
