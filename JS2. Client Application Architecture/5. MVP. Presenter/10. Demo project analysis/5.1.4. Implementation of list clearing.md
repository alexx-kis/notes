# 5.1.4. Реализация очистки списка

- теперь как раз есть проблема: когда выполняется метод `renderTask()`, мы каждый раз создаём экземпляр нового `TaskPresenter` для очередной задачи и вызываем метод `taskPresenter.init(task)`

- есть вопрос, а как нам потом можно получить из `boardPresenter` доступ к какому-то определённому презентеру какой-то задачи?

- в текущей интерпретации это сделать невозможно, потому что просто экземпляр создался и всё

- можно сразу вызвать метод `init()`, а потом больше к нему доступа нет, потому что переменная `taskPresenter` существует только в методе `renderTask`, и с ней ничего не поделать

```js
  #renderTask(task) {
    const taskPresenter = new TaskPresenter({
      taskListContainer: this.#taskListComponent.element,
    });
    taskPresenter.init(task);
    this.#taskPresenters.set(task.id, taskPresenter);
  }
```

- всё сводится к тому, что нужно где-то хранить экземпляры созданных презентеров

- `boardPresenter` должен иметь возможность хранить созданные экземпляры задач

- если мы будем сохранять экземпляр в каком-то поле основного презентера, то мы всегда сможем до него добраться, найти презентер, который соответствует определённой задаче, и с ним повзаимодействовать

- возникает ещё одна проблема: как нам, даже если мы создали, например, массив, где мы будем хранить экземпляры этих классов, понять, какой экземпляр к какой задаче относится?

- нужно, чтобы у каждой задачи был какой-то признак, по которому мы сможем отличать одну задачу от другой

- обычно для этого признака заводят поле идентификатор, которое хранит како-то уникальное значение, которое позволяет отличить одну вещь от другой похожей

- надо подумать, как для каждой задачи завести какое-то поле, в котором будет храниться это уникальное значение, чтобы потом мы могли сказать точно, какая нужна карточка задачи

- если мы попытаемся найти презентер, соответствущий задаче №..., то мы сможем точно сказать, что если мы нашли его, то он соответствует вот именно конкретной задаче

- поэтому нужно ввести в моки дополнительное поле `id`

- в функции `getRandomTask()` мы заводим ещё одно дополнительное поле `id`

- в этом поле мы будем формировать уникальное значение

- вообще у любых данных, которые мы получаем от сервера всегда есть поле `id`

```js
function getRandomTask() {
  return {
    id: nanoid(),
    ...getRandomArrayElement(mockTasks),
  };
}
```

- в качестве идентификатора можно использовать числовую последовательность, но тогда нужно будет хранить информацию о последнем сгенерированном числе - это неудобно

- поэтому мы воспользуемся готовым пакетом `nanoid`

- это нам сейчас нужно на этапе моков, а когда мы будем работать с сервером, к нам будут приходить данные уже с полем `id`

## вернёмся к сохранению экземпляров

- для этого мы можем использовать какую-нибудь коллекцию

- в самом простом случае мы можем эти экземпляры поместить в массив, в итоге в этом массиве было бы n-ное количество экземпляров-презентеров задач

- но с массивом, как с коллекцией работать не очень удобно, потому что, чтобы найти какой-то элемент придётся выполнять поиск по массиву - использовать метод `filter` или `find`

- это неудобно, поэтому использовать массив для хранения списков таких данных мы не будем

- к тому же было бы тяжело удалять какие-то элементы из середины массива

#### можно использовать объект

- в качестве ключа мы будем присваивать `id` задачи, а в качестве значения - экземпляр презентера

```js
allPresenter[task.id] = taskPresenter;
```

- минус этого способа: нам пришлось бы делать какие-то более удобные обёртки, чтобы проверять, а существует ли у нас такой элемент; чтобы добавить элемент, нам пришлось бы использовать скобочную нотацию

#### мы можем воспользоваться коллекцией `Map()`

- преимущества коллекции Map:

  - у этой коллекции есть набор методов для работы (проверка наличия по ключу, метод получения количества элементов, метод добавления элемента итд)

  - в качестве значения ключа могут быть значения любых типов

- из минусов есть то, что нет удобного литерала, как у объекта ( `{}` ) - чтобы его создать, нужно использовать конструктор

- заведём в `boardPresenter` новое свойство, которое назовём `#taskPresenters` и в него создадим экземпляр коллекции `Map`

```js
#taskPresenters = new Map();
```

- в методе `#renderTask(task)` создаём презентер, вызываем метод `init()` и _сохраняем экземпляр_, чтобы потом его можно было найти

- так как `this.#taskPresenters` - это экземпляр коллекции `Map`, мы используем метод `set()`

- в метод `set()` передаются 2 аргумента - данные для ключа и данные для значения

```js
  #renderTask(task) {
    const taskPresenter = new TaskPresenter({
      taskListContainer: this.#taskListComponent.element,
    });
    taskPresenter.init(task);
    this.#taskPresenters.set(task.id, taskPresenter);
  }
```

- таким образом при отрисовке каждой задачи, будет пополняться коллекция `Map` экземплярами-презентерами соответствующих задач

- после такого сохранения можно по `id` находить нужный нужный экземпляр презентера задачи и как-то с ним взаимодействовать

## как это взаимодействие реализовать

- например, нужно очистить весь список задач - убрать все карточки

- мы для этого можем завести `clearTaskList()` в основном презентере и начать итерироваться

- в методе основного презентера `#clearTaskList` итерируемся по коллекции `taskPresenters`, где мы сохранили экземпляры всех презентеров задач

- для каждого элемента коллекции применяется `callback` с методом `destroy()` - который удаляет соответствующий компонент

- затем нужно очистить всю коллекцию `taskPresenters` методом `clear()`

- потом удалить кнопку загрузить-ещё

```js
  #clearTaskList() {
    this.#taskPresenters.forEach((presenter) => presenter.destroy());
    this.#taskPresenters.clear();
    this.#renderedTaskCount = TASK_COUNT_PER_STEP;
    remove(this.#loadMoreButtonComponent);
  }
```

- нам это всё может пригодиться, когда нужно будет осуществить состояние, когда только одна карточка может находиться в режиме редактирования.
