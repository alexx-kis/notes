# Webpack

- Webpack — это сборщик модулей JavaScript с открытым исходным кодом.

![alt text](<images/Логотип webpack.png>)

- Большие приложения невозможно писать в виде одного большого файла с кодом. Обычно код делится на отдельные файлы — модули
- Далее эти модули подключают друг в друга, для этого в современном JavaScript предусмотрен синтаксис import и export
- Он позволяет импортировать и экспортировать различные сущности (функции, классы и так далее) из одного модуля в другой

- Но конечному пользователю JavaScript-код эффективнее поставлять не в десятках (или сотнях, тысячах) файлов, а в одном
- Для этого и нужен webpack — он собирает модули в единый файл, так называемый бандл (от англ. bundle).

- Но прежде чем начать использовать webpack, его нужно установить и настроить

## Установка и настройка webpack

- Для начала работы с webpack установим два пакета: собственно webpack и webpack-cli для работы со сборщиком из консоли:

        npm install -ED webpack webpack-cli

- Мы устанавливаем сборщик как зависимость для разработки (devDependency), потому что он будет использоваться только на этапе разработки и не нужен «на проде»

- Теперь внутри корневой папки создаём файл webpack.config.js
- Он будет содержать настройки, на основе которых webpack собирает проект

- Файл с настройками имеет расширение .js - в нём содержится код на JavaScript, однако этот код рассчитан на работу в Node.js, а не в браузере

### Пример конфигурации webpack:

        const path = require('path');
        const CopyPlugin = require('copy-webpack-plugin');
        const HtmlPlugin = require('html-webpack-plugin');

        module.exports = {
          entry: './src/main.js', // Точка входа
          output: {
            filename: 'bundle.[contenthash].js', // Имя бандла
            path: path.resolve(__dirname, 'build'), // Директория для файлов сборки
            clean: true, // Удаляем предыдущую сборку перед созданием новой
          },
          devtool: 'source-map', // Генерируем карту исходного кода
          plugins: [ // Подключаем плагины
            new HtmlPlugin({
              template: 'public/index.html',
            }),
            new CopyPlugin({
              patterns: [
                {
                  from: 'public',
                  globOptions: {
                    ignore: ['**/index.html'],
                  },
                },
              ],
            }),
          ],
          module: {
            rules: [ // Добавляем лоадеры
              {
                test: /\.js$/,
                exclude: /(node_modules)/,
                use: {
                  loader: 'babel-loader',
                  options: {
                    presets: ['@babel/preset-env']
                  },
                },
              },
              {
                test: /\.css$/i,
                use: ['style-loader', 'css-loader']
              },
            ],
          },
        };

### require и module.exports

- Мы привыкли, что в браузерном JavaScript для импортов и экспортов используются ключевые слова import и export
- Однако в Node.js модули можно связывать и другим способом — с помощью команды require и свойства module.exports
- Этот подход называется CommonJS, он появился в Node.js раньше, чем импорты и экспорты, и до сих пор очень широко используется

### entry

- «Под капотом» webpack строит граф зависимостей
- Начиная со входной точки приложения, сборщик анализирует подключаемые модули и включает их в граф
- В итоге в него попадают все файлы, необходимые для корректной работы приложения

- Точка входа указывается в виде строки в секции entry и имеет относительный путь

### output

- Webpack из множества файлов собирает один, а затем кладёт в определённое место
- Секция output сообщает сборщику, где и как хранить файлы, появляющиеся в результате сборки проекта

- Эта секция состоит из нескольких полей:

  - В поле filename указывается имя файла с итоговым кодом. Оно может быть как конкретным (bundle.js), так и динамическим ([name], [contenthash] и так далее)

  - Поле path отвечает за путь к директории, которая будет создана после сборки проекта. Путь должен быть абсолютным, поэтому при его указании часто используют метод path.resolve, позволяющий «собрать» путь из нескольких частей, например из адреса текущей директории и имени той, которую нужно создать.

  - Поле clean указывает, нужно ли удалять содержимое директории со сборкой при создании новой сборки.

![alt text](<images/Сборка JavaScript-модулей.png>)

### devtool: 'source-map'

- Webpack собирает модули в один файл, а иногда и преобразует код (например, минифицирует)
- Но как быть, если в программу закралась ошибка и необходимо её найти? Обычно для отладки веб-приложений разработчики используют DevTools, однако разобраться в переработанном сборщиком коде очень сложно. И код, и строки, на которые укажет браузер, будут отличаться от тех, что содержатся в исходном коде

- Для решения этой проблемы и существует source map. Это буквально карта исходного кода. Если включить эту функцию, то при сборке проекта рядом с бандлом появится файл <имя бандла>.map.js. И теперь при запуске проекта в DevTools будет показан исходный код, а не его переработанная версия.

### plugins

- Плагины — это вспомогательные инструменты, которые позволяют управлять поведением сборщика
- Плагинов для webpack существует огромное множество
- Каждый имеет собственные настройки, которые к тому же изменяются от версии к версии
- Заучивать их не имеет смысла, лучше опираться на документацию

### loaders

- Лоадеры (часто их ещё называют загрузчиками) — это расширения для webpack, которые описывают, как трансформировать код из одного синтаксиса (или языка) в другой
- Свойство test говорит, для каких файлов нужно применить конкретный лоадер

![alt text](<images/Сборка JavaScript и CSS-модулей.png>)

### Запуск сборки

- Запускать сборку удобнее всего с помощью npm-сценария, описанного в package.json
- При этом можно дополнительно указать, в каком режиме должен быть собран код

- Режима два:

  - development - код собирается быстрее, но не оптимизируется, а потому итоговый бандл весит больше
  - production - сборка занимает больше времени, зато бандл получается меньше

- Как нетрудно догадаться, первый используют на этапе разработки, а второй — для доставки кода пользователям

        "scripts": {
        "build": "webpack --mode production"
        }

- Запускаем сценарий в терминале:

        npm run build

### webpack-dev-server

- Среди богатой инфраструктуры webpack есть также и сервер для разработки
- Он, как LiveServer или BrowserSync, позволяет запускать локальный сервер и обновлять браузер при изменении кода

- Чтобы воспользоваться сервером, сперва нужно установить соответствующий пакет:

        npm install -ED webpack-dev-server

- Настройки сервера прописываются в файле конфигурации самого webpack — webpack.config.js
- Однако с представленной выше конфигурацией сервер запустится и без дополнительной настройки, используя только параметры по умолчанию

- Для запуска сервера удобно добавить в package.json отдельный сценарий:

        "scripts": {
          "start": "webpack serve --mode development --open"
        }

- Флаг --open нужен для того, чтобы приложение сразу открылось в браузере по умолчанию
- Теперь достаточно ввести в терминале:

        npm run start
