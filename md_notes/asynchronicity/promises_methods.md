# Методы глобального объекта Promise #

* Мы познакомились с методами then(), catch() и finally(), которые чаще всего используются с промисами, но у объекта Promise есть ещё несколько «тузов в рукаве»

## Метод all() ##
* Метод all может пригодиться в ситуациях, когда требуется дождаться завершения нескольких промисов
* all() принимает в качестве единственного аргумента массив из промисов и возвращает новый промис, который будет завершён успешно, как только завершатся успешно все переданные в all() промисы
* если хоть один переданный в all() промис завершится с ошибкой, тогда и промис all() будет завершён с ошибкой

* представим, что нам требуется выполнить несколько асинхронных операций, и только потом начать работать с их результатами
* чтобы представить было проще, рассмотрим эту задачу сразу на примере:

		// makeAsyncThing — функция «чёрный ящик», понимать её реализацию не нужно,
		// достаточно запомнить, что она возвращает промис,
		// который будет завершён через 1000 мс

		const makeAsyncThing = (number) => {
			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve(`Это действие №${number}`);
				}, 1000);
			});
		};

		const firstThing = makeAsyncThing(1);
		const secondThing = makeAsyncThing(2);
		const thirdThing = makeAsyncThing(3);

		Promise
			.all([
				firstThing,
				secondThing,
				thirdThing,
			])
			.then((value) => console.log(value));
      
* Функция makeAsyncThing делает бесполезную работу — принимает номер действия и формирует информационную строку, используя этот номер
* дальше мы определяем несколько действий — 1, 2, 3
* наша задача дождаться выполнения всех этих действий, а затем вывести в консоль полученный результат

* В этом нам поможет метод all()
* в качестве параметра мы передаём массив из подготовленных промисов firstThing, secondThing и thirdThing
* результатом будет новый промис, который в случае успешного завершения вернёт также в массиве результаты всех промисов
* таким образом, в коллбэке then() в параметре value будет массив со значениями завершённых промисов firstThing, secondThing и thirdThing

![alt text](01-promise-all.png)
Рисунок 1. Результат применения Promise.all

* обратите внимание на порядок значений в массиве с результатами
* он соответствует порядку переданных в метод all промисов
* чтобы убедиться в этом, в качестве эксперимента вы можете изменить порядок промисов, передаваемых в метод all:

		.all([
			thirdThing,
			firstThing,
			secondThing,
		])
    

* мы нарочно поставили на первое место третий промис
* результаты в массиве тоже сменят порядок:

![alt text](02-promise-all-new-order.png)
Рисунок 2. Результат применения Promise.all в изменённом порядке

* на практике метод all() может применяться, когда нужно получить данные от сервера по нескольким адресам, и только после выполнить с ними какую-то работу

## Метод race() ##

* у объекта Promise есть ещё один полезный метод — race()
* дословно это слово можно перевести как «гонка»
* в отличие от метода all(), он не будет ждать завершения всех промисов, а дождётся завершения одного, который «придёт первым к финишу»

* рассмотрим тот же пример, только вместо all() используем race() и немного модифицируем функцию «чёрный ящик»:

		// makeAsyncThing — функция «чёрный ящик», понимать её реализацию не нужно,
		// достаточно запомнить, что она возвращает промис,
		// который будет завершён через переданное в delay количество мс
		const makeAsyncThing = (number, delay) => {
			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve(`Это действие №${number}`);
				}, delay);
			});
		};

		const firstThing = makeAsyncThing(1, 500);
		const secondThing = makeAsyncThing(2, 1000);
		const thirdThing = makeAsyncThing(3, 2000);

		Promise
			.race([
				firstThing,
				secondThing,
				thirdThing,
			])
			.then((value) => console.log(value));
      
Результат выполнения вы можете увидеть на рисунке ниже:

![alt text](03-promise-race.png)
Рисунок 3. Результат применения Promise.race

* результатом будет строка Это действие №1, не потому что мы первым в race() передали firstThing
* порядок передачи промисов в race() не важен
* всё дело в том, что firstThing имеет меньшую задержку: 500 мс против 1000 мс и 2000 мс у secondThing и thirdThing соответственно

* на практике метод race() может применяться, когда нужно получить похожие данные по нескольким адресам или от нескольких серверов, и выполнить с данными какую-то работу, как только любой источник ответит

## Методы resolve() и reject() ##
* в прошлых главах мы пользовались объектом Promise для создания новых промисов
* это отличный вариант, но в некоторых ситуациях (особенно во время разработки) он многословен
* представьте, что для целей разработки вам нужен промис, который сразу же завершается успешно
* или наоборот, сразу же завершается с ошибкой, для построения цепочки
* в этом случае создавать объект, описывать функцию-исполнитель немного многословно

* к счастью, у объекта Promise есть два метода — resolve() и reject() — которые возвращают промис сразу в нужном состоянии
* первый метод возвращает промис в состоянии завершён успешно, второй — завершён с ошибкой:

		const getData = () => Promise.resolve('Данные загружены!');
		// В getData попадёт промис в состоянии fulfilled

		const getError = () => Promise.reject('Произошла ошибка');
		// В getError попадёт промис в состоянии rejected        
      
* это равносильно, если бы мы написали:

		const getData = () => new Promise((resolve, reject) => resolve('Данные загружены!'));

		const getError = () => new Promise((resolve, reject) => reject('Произошла ошибка'));        
      
* на практике методы resolve() и reject() применяются в первую очередь для целей разработки: проверки кода, написания вспомогательных функций на промисах и т. д.