# 9.20. Тестирование middleware для Redux

# 10. Добавление теста для middleware redirect

- у нас есть middleware redirect, который нужно покрыть тестами
- функция простая, но с точки зрения тестирования здесь есть несколько подводных камней

- наш middleware завязан на объект browserHistory, который мы подготовили самостоятельно, по факту это создание экземпляра BrowserHistory с помощью функции createBrowserHistory()
- этот объект мы подсовываем роутеру и получаем возможность управлять маршрутизацией не только из слоя React
- мы разработали redirect чтобы перенаправлять пользователя на страницу 404, если ресурс не найден

- первая проблема кроется в browserHistory
- у нас middleware напрямую импортирует browserHistory, и это - проблема
- эта проблема связана с тем, что browserHistory завязан на историю управления браузером, и он под node.js жить не может
- во-вторых, таких ситуация бывает много, когда у нас какой-то модуль импортирует какой-то пакет, который не может жить под node.js (а все наши тесты выполняются не в браузере, а под платформой node.js), поэтому, если там что-то не заработает, наш тест не сможет пройти

- вторая проблема: нам нужно понять, что происходит на этапе, когда мы делаем dispatch, меняется ли что-то по отношению к browserHistory

- чтобы это проверить, нужно придумать, что делать с browserHistory
- помимо browserHistory надо что-то сделать со store

## подготовка тестов

- создадим модуль redirect.test.ts
- нам придётся замокать объект browserHistory для тестирования
- тестировать готовые пакеты мы не должны (потому что это должны делать их разработчики)

```ts
describe('Redirect middleware', () => {
  // проверим, что когда мы выполняем dispatch of redirectToRoute, то пользователь должен быть перенаправлен на страницу login
  // чтобы это проверить, мы должны понять, изменилось ли состояние объекта browserHistory
  it('should redirect to "/login" with redirectToRoute action', () => {});
});
```

- vitest предлагает функциональность для создания заглушек
- `vi.mock()` позволяет создать заглушку
- одним из вариантов заглушки может быть заглушка для целого модуля
- мы можем сказать, что, когда у нас будет происходить обращение к какому-то модулю, нужно не использовать тот оригинальный модуль, а использовать то, что мы захотим использовать
- например, мы можем сказать, что, когда у нас происходит обращение к значению default и получает browserHistory, мы можем сделать так, чтобы вместо оригинального модуля выполнялась наша функция и возвращала какой-то объект
- таким образом мы замокаем модуль browserHistory, и, когда любой код мы будем проверять, на самом деле будет использоваться наша заготовка

```ts
// первым аргументом передаём модуль, который мы хотим замокать
// вторым - функцию, которая должна возвращать то, что мы будем использовать вместо этого модуля (имитируем модуль)
// поскольку модуль использует ключевое слово default при экспорте, функция должна возвращать объект по дефолту
vi.mock('../../browser-history', () => ({
  default: {
    // когда происходит перенаправление пользователя, у нас меняется свойство locationPathName, оно приобретает новый путь
    // чтобы изменить этот путь, мы вызываем метод push()
    location: { pathname: '' },
    push(path: string) {
      this.location.pathname = path;
    },
  },
}));
```

- так как в middleware у нас есть обращение к store, нам нужно имитировать хранилище
- для этого мы можем воспользоваться специализированным пакетом `@jedmao/redux-mock-store`
- мы должны подготовить имитированный store, который по факту будет содержать все методы хранилища, и мы сможем тем самым проверять, как у нас происходит взаимодействие с хранилищем
- настоящее хранилище при этом поднято не будет

- в describe объявим переменную store типа MockStore (это тип фейкового хранилища) из пакета @jedmao/redux-mock-store
- этот тип может сам не предложить импорт, и его надо будет написать вручную

```ts
describe('Redirect middleware', () => {
  let store: MockStore;
});
```

- теперь нужно выполнить подготовку хранилища
- по большому счёту это та операция, которую нужно выполнить до выполнения всех тестов
- можно описать прямо в блоке describe
- но vitest, как и многие тестовые фреймворки, предлагает дополнительные инструменты - хуки - методы жизненного цикла тестов
- эти хуки позволяют выполнить какой-то код, например, перед всеми тестами, перед каждым тестом, после всех тестов или после каждого теста
- хук beforeAll позволяет подготовить окружение (можно сымитировать хранилище)
- это всё мы подготовим, чтобы потом использовать на протяжении всего тестирования
- в хуке beforeEach мы можем делать какие-то дополнительные действия, например, очищать состояние хранилища

```ts
describe('Redirect middleware', () => {
  let store: MockStore;

  // воспользуемся хуком beforeAll, по факту это обычная функция, которой нужно передать callback, внутри которого выполнить какие-то действия
  beforeAll(() => {
    // подготовим хранилище
    // создадим переменную middleware и поместим в неё массив с redirect (который в redirect.ts)
    const middleware = [redirect];

    // для имитации store воспользуемся функцией configureMockStore
    // через параметры типа мы должны указать все значения, которые позволять типизировать наш store
    // в качестве типа store указываем State
    // для типа действия пропишем просто AnyAction
    // аргументом передаём созданный массив с middleware
    const mockStoreCreator = configureMockStore<State, AnyAction>(middleware);

    // в store запишем результат выполнения функции mockStoreCreator
    store = mockStoreCreator();
  });

  it('should redirect to "/login" with redirectToRoute action', () => {});
});
```

- мы воспользовались хуком beforeAll, и код, который внутри, будет выполняться перед всеми тестами

- также мы можем воспользоваться хуком beforeEach
- когда мы будем взаимодействовать с историей браузера - выполнять какие-то перенаправления - мы по факту будем изменять состояние browserHistory
- под состоянием подразумевается изменение свойства pathname

```ts
describe('Redirect middleware', () => {
  let store: MockStore;

  beforeAll(() => {
    const middleware = [redirect];
    const mockStoreCreator = configureMockStore<State, AnyAction>(middleware);
    store = mockStoreCreator();
  });

  beforeEach(() => {
    // здесь, чтобы у нас не возникало ошибок, что мы, например, перенаправили пользователя куда-то, потом выполняем сравнение, а там другой маршрут, мы будем очищать текущий pathname
    // для этого обращаемся к browserHistory, и перенаправляем на маршрут с пустой строкой
    browserHistory.push('');
  });

  it('should redirect to "/login" with redirectToRoute action', () => {});
});
```

- этого достаточно для базовой работоспособности тестов

## теперь напишем сами тесты

```ts
it('should redirect to "/login" with redirectToRoute action', () => {
  // объявляем переменную redirectAction, и чтобы получить само действие, мы должны вызвать redirectToRoute
  // аргументом передаём AppRoute.Login
  const redirectAction = redirectToRoute(AppRoute.Login);

  // выполним dispatch этого действия
  // здесь store - это наш фиктивный store который мы имитируем (создаём в начале describe)
  store.dispatch(redirectAction);

  // выполняем сравнение
  // мы ожидаем, что после dispatch этого действия в browserHistory в свойстве pathname должно быть значение AppRoute.Login
  expect(browserHistory.location.pathname).toBe(AppRoute.Login);

  // таким образом, если в состоянии browserHistory появится этот путь, значит, наш middleware работает правильно
});
```

- проверим и обратный вариант - если мы не используем действие redirectToRoute, а просто в payload передаём путь к какому-то маршруту для неизвестного действия, то перенаправления случиться не должно, и в состоянии browserHistory будет пустая строка

```ts
it('should not redirect to "/lose" with empty action', () => {
  // объявим пустое действие
  // поле типа - пустое, полезная нагрузка - путь к AppRoute.Lose
  const emptyAction = { type: '', payload: AppRoute.Lose };

  // затем выполним dispatch этого пустого действия
  store.dispatch(emptyAction);

  // выполним проверку
  // убедимся, что поле pathname свойства location объекта browserHistory не станет равно AppRoute.Lose, с помощью метода `not`
  expect(browserHistory.location.pathname).not.toBe(AppRoute.Lose);
});
```
