# Псевдонимы типов и интерфейсы

- В TypeScript существует два ключевых оператора для работы с типами: type и interface
- Эти операторы часто используются для выполнения схожих задач, но между ними есть несколько важных различий, которые могут повлиять на выбор одного из них в различных ситуациях

## 1. Псевдонимы типов (type)
Оператор type позволяет создавать псевдонимы для существующих типов. Это не создает новый тип, а просто предоставляет альтернативное имя для уже существующего типа. Например:

```ts
type OrderNumber = string;
const myOrderNumber: OrderNumber = '31337';
```

- Здесь OrderNumber — это псевдоним для типа `string`
- Когда вы используете OrderNumber, фактически работаете с типом `string`

## 2. Взаимозаменяемость `type` и `interface`
- В большинстве случаев можно использовать как `type`, так и `interface` для описания структуры объекта

#### Рассмотрим примеры:

- С использованием type:

```ts
type Order = {
  id: string;
  createdAt: Date;
  items: string[];
};
```

- С использованием interface:

```ts
interface Order {
  id: string;
  createdAt: Date;
  items: string[];
}
```

- Обе записи определяют структуру объекта с одинаковыми свойствами
- Однако есть ключевые различия.

## 3. Особенности `interface`

### Слияние интерфейсов

- При объявлении нескольких интерфейсов с одинаковыми именами они автоматически сливаются в один
- Это полезно в ситуациях, когда нужно расширить интерфейсы, например, при разработке библиотек

#### Пример слияния интерфейсов:

```ts
interface Order {
  id: string;
  createdAt: Date;
  items: string[];
}

interface Order {
  status: string;
}

const myOrder: Order = {
  id: '31337',
  createdAt: new Date(),
  items: ['orange', 'banana'],
  status: 'created',
};
```

### Наследование интерфейсов

- Интерфейсы могут наследовать другие интерфейсы, что полезно в объектно-ориентированном программировании. Например:

```ts
interface Cat {
  meow: () => void;
}

interface FastCat extends Cat {
  run: () => void;
}

class Tiger implements FastCat {
  meow() { console.log('meow-meow'); }
  run() { console.log('run'); }
}
``` 
## 4. Ограничения type

### Пересечение типов

- С помощью `type` можно создавать пересечения типов с использованием оператора `&` 
- Это позволяет комбинировать свойства нескольких типов в один новый тип:

```ts
type OrderIdentifier = { id: string };
type OrderStatus = { status: string };
type Order = OrderIdentifier & OrderStatus;
```

### Объединение типов

- Оператор type поддерживает объединение типов через оператор `|`, что позволяет создавать тип, который может быть одним из нескольких вариантов:

```ts
type Dog = { bark: () => void };
type Cat = { meow: () => void };
type Animal = Dog | Cat;
```

## 5. Псевдонимы и интерфейсы с классами

- Интерфейсы лучше подходят для работы с классами, потому что они поддерживают наследование и слияние
- Псевдонимы типов не могут быть реализованы классами

#### Пример интерфейса с классом:

```ts
interface Animal {
  sound(): void;
}

class Dog implements Animal {
  sound() {
    console.log('Woof!');
  }
}
```

## 6. Кортежи

- Кортежи, которые представляют собой упорядоченные наборы значений фиксированной длины, можно объявлять с помощью `type`, но не с помощью `interface`:

```ts
type Developer = [string, string, number]; // допустимо
```

- В интерфейсе кортежи объявить нельзя, хотя их можно использовать как часть объекта

## 7. Когда использовать `type`, а когда `interface`

- Используйте `interface`, если вам нужно расширить интерфейсы или использовать их с классами, а также для описания структур объектов, которые могут быть изменены через слияние

- Используйте `type`, если нужно объединить или пересечь несколько типов, а также для работы с кортежами или сложными типами, которые не требуют расширяемости

## Резюме

- `interface` подходит для описания объектов, которые могут быть расширены или реализованы классами. Оно поддерживает слияние и наследование

- `type` используется для создания псевдонимов типов, объединения и пересечения типов, а также для работы с кортежами

- В общем, выбор между `type` и `interface` зависит от ваших требований к гибкости, расширяемости и тому, как планируется использовать описанные типы