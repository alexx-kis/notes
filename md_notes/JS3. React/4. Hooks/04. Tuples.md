# Кортежи

- Кортеж (tuple) — это упорядоченный набор фиксированной длины, хранящий элементы разных типов
- Длина кортежа и порядок типов задаются при его создании и не могут быть изменены
- Например, в JavaScript кортежи отсутствуют на уровне языка, но их можно эмулировать с помощью массивов, применяя метод `Object.freeze` для предотвращения изменения длины и значений:

```javascript
const createTuple = (...params) => Object.freeze(params);

const myFirstTuple = createTuple(1, 'Keks', true);
console.log('Исходный кортеж:', myFirstTuple); // [1, 'Keks', true]

// Попытка изменить значение
myFirstTuple[0] = 2;
console.log(myFirstTuple); // [1, 'Keks', true]

// Попытка добавить элемент
myFirstTuple.push('JavaScript'); // TypeError
```

## Зачем нужны кортежи?

- Кортежи удобны, когда нужно гарантировать строгую структуру данных
- Рассмотрим пример: массив имён пользователей типа `string[]` не позволит добавить идентификатор пользователя числового типа:

```ts
const users: string[] = ['Игорь', 'Елена'];

// Ошибка: массив может содержать только строки
users.push(123);
```

- Использование типа `any[]` решает проблему, но лишает массив преимуществ строгой типизации:

```ts
const users: any[] = ['Игорь', 'Елена'];
users.push(123); // ОК, но теряется контроль типов
```

- Альтернативой может быть объединение типов `(string | number)`, но оно не контролирует порядок элементов
- Если требуется, чтобы, например, первый элемент всегда был строкой, а второй — числом, лучше использовать кортеж

## Кортежи в TypeScript

- TypeScript поддерживает кортежи через синтаксис массивов с указанием типов:

```ts
const user: [string, number] = ['Игорь', 31337];
```

- Этот кортеж содержит два элемента: первый — строка, второй — число
- Нарушение порядка или количества элементов вызовет ошибку:

```ts
user = [31337, 'Игорь']; // Ошибка: нарушен порядок типов
user = ['Игорь', 31337, 'Keks']; // Ошибка: превышено количество элементов
```

## Особенности и ограничения

- Кортежи позволяют изменять значения элементов, если они соответствуют заданным типам:

```ts
user[0] = 'Keks';
user[1] = 1;
console.log(user); // ['Keks', 1]
```

- Для защиты от изменений можно использовать модификатор `readonly`:

```ts
const user: readonly [string, number] = ['Игорь', 31337];

// Ошибка: нельзя редактировать элементы
user[0] = 'Keks';
```

- Однако существует нюанс: TypeScript не предотвращает вызов метода `push`, позволяющего добавить элементы, но получить их невозможно:

```ts
user.push('keks'); // ОК, но доступ к элементу невозможен
console.log(user[2]); // Ошибка
```

## Деструктуризация

- Кортежи поддерживают деструктуризацию, как и массивы
- Это часто используется в React с хуком `useState`:

```ts
const [username, id] = user;
console.log(username, id); // 'Игорь', 31337
```

- Кортежи полезны, когда требуется строгий контроль типов и порядка элементов, что делает их удобным инструментом для описания сложных структур данных.
