# 9.16. Тестирование селекторов gameProcess

# 9.5. Добавление тестов для селекторов GameProcess

- тестируем функции-селекторы, это чистые функции, их тестировать намного проще

- начнём с gameProcess
- у нас есть 2 функции getStep, которая возвращает шаг игры, на котором мы находимся, и getMistakesCount, которая возвращает количество ошибок
- на вход они принимают объект состояния и возвращают какую-то определённую его часть
- возможно, при написании теста, мы увидим, что возникают какие-то неудобства, и нам придётся эти функции немного изменить

- создадим модуль game-process.selectors.test.ts
- объявим группу с помощью функции describe(), назовём 'GameProcess selectors' и опишем первый тест
- нам нужно убедиться, что функции-селекторы возвращают значения из состояния
- сразу объявим переменную result (начнём со стадии Act), присвоим ей результат выполнения функции getMistakeCount, ей нужно передать state
- перед result объявим переменную state и опишем состояние

```ts
describe('GameProcess selectors', () => {
  const state = {
    [NameSpace.Game]: {
      mistakes: 3,
      step: 4,
    },
  };
  const result = getMistakeCount(state);
});
```

- здесь мы сталкиваемся с первой проблемой: мы описали объект состояния, по факту - это заглушка, и, когда мы передаём этот объект в getMistakeCount(), чтобы потом эта функция могла извлечь нам значение поля mistakes, мы получаем ошибку от typescript, что у нас несовпадение типов
- так происходит, потому что наши функции-селекторы принимают весь объект состояние, и в качестве типа у нас State, который выводится с помощью хелпера ReturnType

```ts
export type State = ReturnType<typeof store.getState>;
```

- функциям-селекторам getMistakeCount() и getStep() не нужен полностью объект состояния, хотя бы на уровне типов, потому что эти функции работают только с определённой частью состояния (Game)
- поэтому указывать в качестве типа State расточительно, и мы можем немного сэкономить - мы можем указать, что аргументом должен приходить объект, у которого точно есть ключ game, и у этого ключа уже есть необходимые свойства (mistakes и/или step)
- у нас есть тип GameProcess и мы можем им воспользоваться, то есть мы можем обновить таким образом функции-селекторы
- но, лучше, если мы воспользуемся функциями-хелперами, которые нам предоставляет typescript
- здесь мы можем воспользоваться функцией pick, которая позволяет нам конструировать новый тип на основании существующего
- воспользуемся функцией pick, в качестве параметра типа передадим ей тип, который будет браться за основу (State), вторым аргументом мы должны указать ключи, которые должны остаться в результирующем объекте
- проще говоря, мы берём тип, и оставляем только то, что укажем вторым аргументом (NameSpace.Game)

```ts
export const getMistakeCount = (state: Pick<State, NameSpace.Game>): number =>
  state[NameSpace.Game].mistakes;
```

- теперь в описании теста у нас не будет ошибки при вызове функции getMistakeCount(), потому что теперь наш объект состояния соответствует типу

- дальше напишем логику проверки и выполнить сравнение

- напишем код проверки:

```ts
expect(result).toBe(3);
```

- для второй функции getStep() также воспользуемся pick

```ts
export const getStep = (state: Pick<State, NameSpace.Game>): number =>
  state[NameSpace.Game].step;
```

- напишем отдельный тест для функции getStep() по аналогии
- у нас один моковый объект, поэтому мы можем его вынести из тестовых случаев на уровень выше
- для того чтобы вытащить нужные свойства, участвующие в сравнении, воспользуемся деструктуризацией

```ts
describe('GameProcess selectors', () => {
  const state = {
    [NameSpace.Game]: {
      mistakes: 3,
      step: 4,
    },
  };

  it('should return mistakes count from state', () => {
    const { mistakes } = state[NameSpace.Game];
    const result = getMistakeCount(state);
    expect(result).toBe(mistakes);
  });

  it('should return step number from state', () => {
    const { step } = state[NameSpace.Game];
    const result = getStep(state);
    expect(result).toBe(step);
  });
});
```
