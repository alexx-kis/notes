# Создание структуры данных и добавление модели в приложение
(на примере демо-проекта task manager)

- когда мы начинаем готовить тестовые данные (моки), нам нужно подумать про инфраструктуру - а где мы всё это будем хранить

- тестовые данные нужно сохранить в отдельной директории, потому что может быть несколько разных файлов, и скорее всего потом эти данные перестанут быть нужны, и мы их можем удалить

- для этого в папке src нужно создать отдельную директорию mock

- нам наверняка потребуются какие-то вспомогательные универсальные функции, которые помогут подготовить тестовые данные: например, функция получения случайных элементов

- по тестовому заданию может быть указано, что, например, нужно отображать восемь каких-то элементов. Эту восьмёрку надо где-то хранить - в константах

- таким образом, появляются три таких элемента, которые нужно где-то разместить:
  1. константы -> const.js
    - могут быть использованы во всём приложении
  2. моки -> /mock/task.js (вместо task может быть любое другое название, отражающее содержимое)
  3. функции -> utils.js
    - вспомогательные функции, например, для получения случайных элементов

### Модуль utils.js

- в этом модуле располагаются все вспомогательные функции, необходимые для разработки проекта

- для проекта точно пригодится функция getRandomArrayElement()

const getRandomArrayElement = (items) => {
  return items[Math.floor(Math.random() * items.length)];
}

### Модуль const.js

- например, количество элементов, которые нужно отрисовать
- все цвета, которые используются

### Модуль mock.js

- в ней файл task.js
- в этот файл импортируются константы и вспомогательные функции

- можно самостоятельно вручную написать эти данные

- объявляем массив mockTasks, который содержит список всех задач, которыми мы можем пользоваться на этапе разработки, и каждую задачу мы будем описывать в виде отдельного объекта

- описываем объект:

        {
          description: 'Сделать домашку',
          dueDate: null,
          repeating: {
            mo: false,
            tu: false,
            we: true,
            th: false,
            fr: false,
            sa: true,
            su: false,
          },
          color: getRandomArrayElement(COLORS),
          isArchive: false,
          isFavorite: true,
        },

- description - описание задачи
- dueDate - срок выполнения задачи
- repeating - объект, в котором перечислены дни недели и значение true для тех дней, по которым задача повторяется
- color - цвет, которые выбирается случайно
- isArchive - показывает, находится ли задача в архиве
- isFavorite - показывает, находится ли задача в избранном

- в массиве задач создадим несколько таких задач

- в этом же файле нужна ещё функция getRandomTask, которая возвращает случайную задачу из массива
- она нужна, чтобы мы не думали, что за случайный элемент какого-то массива, а сразу понимали, что это случайный элемент из массива задач

        const getRandomTask = () => {
          return getRandomArrayElement(mockTasks);
        }

## Модель

- моделей может быть несколько, поэтому их нужно размещать в отдельной директории model на том же уровне, на котором view и presenter

- модель - это обычный js-модуль, в котором описывается класс
- все классы экспортируются по умолчанию на данном курсе

- файл модели называется по шаблону name-model.js
- класс внутри соответствует названию файла - NameModel

- этот класс описывает структуру модели, место, где хранятся данные и предоставляет методы для управлению данными
- пока модель только отдаёт данные с помощью метода getTasks

        export default class TasksModel {
          tasks = Array.from({length: TASK_COUNT}, getRandomTask);

          getTasks() {
            return this.tasks;
          }
        }

- в свойство tasks мы записываем массив задач способом Array.from
- способ Array.from позволяет создать массив из итерируемого объекта
- особенность метода from в том, что он вторым аргументом принимает callback функцию, которая будет применена к каждому элементу массива
- по факту эта функция работает, как callback функция метода map массива
- первым аргументов в метод .from мы передаём объект {length: /количество элементов/}

### Подключение модели

- подключаем модель в точке входа
- с моделью взаимодействует презентер, поэтому ему и нужно передать эту модель

- создаём экземпляр модели

        const TasksModel = new TasksModel()

- в презентер передаём TasksModel после контейнера
- в презентер передаётся деструктурированный объект, который попадает в конструктор

- передаём модель в презентер:

        const boardPresenter = new BoardPresenter({
          boardContainer: siteMainElement,
          tasksModel,
        });

- в классе презентера принимаем модель через конструктор:

        export default class BoardPresenter {
          boardComponent = new BoardView();
          taskListComponent = new TaskListView();

          constructor({boardContainer, tasksModel}) {
            this.boardContainer = boardContainer;

            // заводим свойство taskModel, в котором будет храниться передаваемая модель
            this.tasksModel = tasksModel;
          }

          init() {

            // теперь все данные получаются из модели
            // создаём новое свойство boardTasks и в него сохраняем всё, что нам вернёт getTasks() с помощью ...-оператора (копируем)
            this.boardTasks = [...this.tasksModel.getTasks()];

            render(this.boardComponent, this.boardContainer);
            
            ...
          }
        }

- зачем копировать данные из модели в презентер? - мы это делаем в качестве временного решения
- пока что наша модель - это заготовка, которая может только отдавать данные, для упрощения мы будем копировать все данные в презентер
- потом мы прокачаем модель и избавимся от копирования в презентер

- теперь, когда у нас есть все необходимые данные, мы можем уже опираться на них при отрисовке задач:

        export default class BoardPresenter {

          ...

          init() {
            ...

            for (let i = 0; i < this.boardTasks.length; i++) {
              render(new TaskView({task: this.boardTasks[i]}), this.taskListComponent.getElement());
            }
            ...
          }
        }

- здесь не подойдёт метод forEach, так как мы в будущем будем итерироваться не с первого элемента

- при создании экземпляра TaskView мы ему передаём данные из модели через конструктор

        new TaskView({task: this.boardTasks[i]})

