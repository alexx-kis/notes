# 4.1.6 Добавление логики допоказа задач. WIP

- добавим функциональность для кнопки "load more" чтобы по нажатию выводились ещё задачи из списка

- в модели увеличим количество отображаемых задач

- в компоненте `LoadMoreButtonView` нужно создать обработчик

- а как это делать, используя паттерн MVP? где описывать этот обработчик? и как прокидывать какие-то действия?

- здесь мы должны прийти к какой-то договорённости, которая будет применяться при решении похожих задач (организация поведений для наших view)

### как можно передавать информацию в компонент

1. создавать публичные свойства и записывать информацию в них

   - способ хороший, но свойства будут постоянно разниться от компонента к компоненту и рано или поздно с ними будет сложно взаимодействовать потому что их будет разное количество и они будут разными - какие- то свойства будут нужны только внутри компонента, а какие-то будут нужны для записи информации снаружи

2. можно использовать конструктор

- а в каком виде мы должны всё это передавать?

  1.можно передавать в виде отдельных компонентов, но наверняка появится компонент, который будет требовать слишком много аргументов, и это будет просто неудобно

  2.можно использовать объекты, то есть в конструктор мы будем передавать данные в виде объекта

- чтобы было проще отличать просто данные от обработчиков, мы будем обработчики именовать с префикса `on-`

- опишем в компоненте `LoadMoreButtonView` конструктор, где аргументом будет приходить объект, а в этом объекте - обработчик, то есть callback-функция, которая будет вызываться по нажатию на кнопку, будет доступна в свойстве `onClick`

- этот callback придётся вызывать, и возможно в этом callback не будет всей какой-то логики, может быть какая-то внутренняя логика компонента, например, отмена действия по умолчанию, и мы вполне можем эту функциональность реализовать во внутреннем обработчике компонента

- поэтому сохраним callback, который нам необходимо будет вызывать, в приватном свойстве `#handleClick`

- то есть мы сохраняем ссылку на обработчик, и он у нас будет использоваться в тот момент, когда потребуется

- дальше, чтобы у нас что-то сработало по нажатию на кнопку, нужно подписаться на соответствующее событие с помощью метода `addEventListener`

- обратите внимание, как мы его используем: мы уже не ищем эту кнопку во всём документе нашей страницы, мы обращаемся к свойству `this.element`

- `this.element` - это на самом деле геттер, который возвращает содержимое приватного свойства `#element`

- поэтому в данном случае в `element` будет находиться сама кнопка, то есть DOM-элемент, который появляется в результате отрисовки кнопки

- затем нужно в `addEventListener` указать тип события и обработчик, который будет вызываться

- обратите внимание, что здесь вызывается приватный обработчик (`#clickHandler`)

- в теле обработчика отменяем действие по умолчанию, а затем вызываем `#handleClick()` - обработчик - который пришёл в конструктор, и который мы сохранили в свойство `#handleClick`

- таким образом, передавая логику для компонента снаружи, можно добиться его универсальности, например, на разных страницах эта кнопка сможет загружать разные штуки

- а вот если бы логика нажатия на кнопку всегда была бы одинаковой, то это можно было бы описать в `#clickHandler`

```js
class LoadMoreButtonView extends AbstractView {
  #handleClick = null;

  constructor({ onClick }) {
    super();
    this.#handleClick = onClick;
    this.element.addEventListener('click', this.#clickHandler);
  }

  get template() {
    return createLoadMoreButtonTemplate();
  }

  #clickHandler = (e) => {
    e.preventDefault();
    this.#handleClick();
  };
}
```

### как реализуется функциональность кнопки

- эта функциональность присутствует в презентере

- нужно определить, сколько задач будет показываться при нажатии на кнопку и просто при первоначальном выводе (8)

- зафиксируем это количество в константу `TASK_COUNT_PER_STEP = 8`

- внутри презентера также потребуется экземпляр компонента `LoadMoreButtonComponent`, поэтому мы для него подготовим приватное свойство `#loadMoreButtonComponent = null;`

- также зафиксируем в приватном свойстве `#renderedTaskCount` - количество отрендеренных задач и по умолчанию этим значением будет `TASK_COUNT_PER_STEP`

- дальше мы должны написать логику отображения задач, пока в методе `init()`, потом мы её вынесем

- в методе `init()` мы должны ограничить количество задач, которые мы должны отрисовать

- будем использовать `Math.min` и соответственно отрисовывать количество задач, которое у нас есть, либо меньшее количество, если задач в принципе меньше (не факт, что при старте приложения у нас будет больше 8 задач, может быть и меньше)

```js
init() {
  //...
  for (let i = 0; i <Math.min(this.#boardTasks.length, TASK_COUNT_PER_STEP); i++) {
    this.#renderTask(this.#boardTasks[i]);
  }
}
```

- дальше в методе `init()` мы должны выполнить проверку, что если у нас задач больше чем значение в `TASK_COUNT_PER_STEP`, то нам потребуется отрисовать кнопку загрузки `LoadMore`

- то есть если таких задач действительно больше чем `TASK_COUNT_PER_STEP`, мы создадим экземпляр кнопки, присвоим здесь обработчик - то есть передадим в конструктор объект, в этом объекте сделаем свойство `onClick` и укажем ссылку на обработчик (`this.#handleLoadMoreButtonClick`)

```js
if (this.#boardTasks.length > TASK_COUNT_PER_STEP) {
  this.#loadMoreButtonComponent = new LoadMoreButtonView({
    onClick: this.#handleLoadMoreButtonClick,
  });
  render(this.#loadMoreButtonComponent, this.#boardComponent.element);
}
```

- `#handleLoadMoreButtonClick` - это отдельный метод в презентере, именно в нём будет находиться логика, которая будет выполняться при нажатии на кнопку

- теперь нужно отрисовать экземпляр (в условии)

- `#handleLoadMoreButtonClick`: описываем логику, которая будет выполняться при нажатии на кнопку

- здесь нам нужно взаимодействовать с нашим списком задач, и каждый раз "откусывать" от этого списка очередное количество задач

- то есть нам нужно брать часть задач методом `slice` и показывать

- когда мы показали очередную часть задач - обратились к `this.#boardTasks`, взяли какое-то количество задач, потом мы по ним итерируемся (`slice` возвращает новый массив) методом `forEach` и отрисовываем каждую задачу

- попутно увеличиваем значение приватного свойства #`renderedTaskCount` на `TASK_COUNT_PER_STEP`

- дальше проверяем, что если мы отрисовали уже все задачи, то необходимости в кнопки `loadMoreButtonComponent` уже нет, её можно смело удалять

- для удаления есть специальный метод `remove`, который предусмотрен фреймворком

```js
#handleLoadMoreButtonClick = () => {
  this.#boardTasks
    .slice(this.#renderedTaskCount, this.#renderedTaskCount + TASK_COUNT_PER_STEP)
    .forEach((task) => this.#renderTask(task));
    this.#renderedTaskCount += TASK_COUNT_PER_STEP;
    if (this.#renderedTaskCount >= this.#boardTasks.length) {
      remove(this.#loadMoreButtonComponent);
    }
}
```

### ещё про организацию компонента loadMoreButtonView

- когда мы описывали обработчик `#clickHandler`, мы описывали синтаксис со стрелочной функцией

- дело в том, что когда мы подписываемся на какое-то событие, если бы метод `#clickHandler` был бы обычной функцией, то внутри обработчика события значением `this` будет ссылка на DOM-элемент, на котором произошло событие, вместо ссылки на текущие экземпляр объекта, из-за этого мы не смогли бы вызвать внутри какой-то другой метод объекта или обратиться к его свойству

- чтобы не использовать в конструкторе метод `bind()`, мы используем стрелочную функцию
