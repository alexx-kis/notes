# 9.30. FireEvent. Имитируем события в DOM (AudioPlayer)

# 9.18. Имитирование события. Тестирование AudioPlayer

- бывают ситуации, когда необходимо имитировать не только события, которые может сделать пользователь, но и те события, которые могут происходить в результате завершения какой-то асинхронной операции

- в приложении "Угадай мелодию" перед тем, как мелодия должна воспроизвестись, нужно чтобы загрузился сам файл с мелодией

- когда он будет загружен, срабатывает событие dataLoaded, и только после него мы можем эту мелодию воспроизводить

- когда мы разрабатывали компонент плеера, мы делали на это расчёт - кнопка воспроизведения по умолчанию заблокирована, как только будут загружены данные, мы сможем её разблокировать и предоставить пользователю возможность воспроизводить мелодию

- здесь получается, что нам не нужно имитировать действие пользователя, потому что, когда приложение стартует, у нас сразу же начинается загрузка мелодий, и браузер сгенерирует соответствующее событие, когда мелодия будет загружена

- для этого в React Testing Library есть ещё один инструмент - fireEvent, который позволяет имитировать различные события

- если на него смотреть с точки зрения имитаций действий пользователя, он работает не очень, потому что он имитирует именно конкретное событие, а не цепочку событий, как это случается с userEvent

- но когда нам нужно добиться имитации какого-то события, например, завершения загрузки данных или что-то в этом роде, fireEvent подходит

- в компоненте AudioScreen используется элемент `<audio>` (на него уже закреплён data-testid)

- здесь идёт подписка на событие 'loadeddata'

```tsx
useElementListener('loadeddata', audioRef, handleDataLoaded);
```

- кастомный хук useElementListener позволяет подписаться на событие в DOM

- когда событие произойдёт, мы сможем разблокировать кнопку, и пользователь сможет начать пользоваться плеером

- здесь классы - это возможность показать состояние кнопки

```tsx
<button
  className={cn(
    'track__button',
    { 'track__button--play': !isPlaying },
    { 'track__button--pause': isPlaying }
  )}
  type='button'
  disabled={!isLoaded}
  onClick={onPlayButtonClick}
/>
```

- это хороший кейс для тестирования, потому что следуя канонам React Testing Library, мы не должны привязываться на классы, но здесь нам нужна такая привязка, так как по-другому мы никак не сможем понять, что нужная иконка отображается

```tsx
import { fireEvent, render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import AudioPlayer from './audio-player';
import { internet } from 'faker';

describe('Component: AudioPlayer', () => {
  // начнём с теста на правильность отрисовки
  it('should render correctly', () => {
    const mockMelodyPath = internet.url();

    // создадим функцию-заглушку
    // мы сможем получить какую-то мета-информацию об этой функции, например, вызывали ли её
    const mockHandleClick = vi.fn();

    // отрисовываем компонент
    render(
      <AudioPlayer isPlaying src={mockMelodyPath} onPlayButtonClick={mockHandleClick} />
    );

    // проверяем кнопку
    // ищем кнопку по роли
    expect(screen.getByRole('button')).toBeInTheDocument();
    // ищем элемент по testid
    expect(screen.getByTestId('audio')).toBeInTheDocument();

    // затем мы должны убедиться, что кнопка по умолчанию выключена
    expect(screen.getByRole('button')).toBeDisabled();

    // если нужно проверить применяемость классов, можно воспользоваться методом toHaveClass
    // по этому классу в данном кейсе можно понять, какая иконка отображается на кнопке
    expect(screen.getByRole('button')).toHaveClass('track__button--pause');
  });

  // здесь мы должны проверить, что кнопка "Play" становится активной, когда загружена мелодия
  // для этого надо сымитировать событие, что данные загружены
  it('should play button enable when data loaded', async () => {
    // на стадии подготовки делаем то же самое, что и в предыдущем тесте
    const mockMelodyPath = internet.url();
    const mockHandleClick = vi.fn();
    {
      HTMLMediaElement.prototype.play = vi.fn();
    }

    // рендерим компонент
    render(
      <AudioPlayer isPlaying src={mockMelodyPath} onPlayButtonClick={mockHandleClick} />
    );

    // вызываем функцию fireEvent
    // первым аргументом передаём сам элемент, для которого необходимо имитировать событие
    // вторым аргументом передаём объект события - какое событие нужно сымитировать
    fireEvent(screen.getByTestId('audio'), new Event('loadeddata'));

    // раз данные загрузились, кнопка стала активной, значит по ней можно кликнуть
    // здесь обращаемся к userEvent - имитируем действие пользователя
    // передаём кнопку, найденную по роли
    await userEvent.click(screen.getByRole('button'));

    // убеждаемся, что функция, которая была вызвана по клику по кнопку, была действительно вызвана
    expect(mockHandleClick).toBeCalledTimes(1);

    // убеждаемся, что кнопка активна
    expect(screen.getByRole('button')).not.toBeDisabled();
  });
});
```

- когда мы тестируем компоненты, которые опираются на на возможности, имеющиеся только в браузере (например `<AudioPlayer>`), то мы должны помнить, что наши тесты могут упасть, как раз из-за этого, когда мы в данном случае кликаем по кнопке, которая впоследствии активирует у объекта Audio метод Play, и соответственно
- наш тест хоть и проходит, но если мы запустим все тесты в терминале, то мы по идее должны получить ошибку, что метод Play:

```bash
Error: Not implemented: HTMLMediaElement.prototype.play
```

- в этом случае, мы можем воспользоваться HTMLMediaElement
- укажем prototype.play = присвоим фейковую реализацию

```tsx
// добавим вот эту строку на стадии подготовки
HTMLMediaElement.prototype.play = vi.fn();
```

- этого будет достаточно
- мы фактически сказали, что у нас метод `play` имеет вот такую реализацию (`vi.fn()`)

- теперь все тесты проходят
