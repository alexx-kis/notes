# РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ #

* регулярные выражения (Regular Expressions, regex, regexp, регулярки) — специальные шаблоны, которые используют для поиска и обработки текста
* для поиска в них можно задавать дополнительные команды, например игнорирование регистра

* в отличие от обычных функций поиска и замены, которые встречаются во всех текстовых редакторах, регулярные выражения могут сочетаться с другим кодом
* с их помощью можно выполнять сложные операции с текстом, менять порядок строк, извлекать отдельные слова, валидировать и передавать информацию на сервер
* ещё регулярки экономят очень много кода 
* недостаток — они часто выглядят пугающе, запутанно и странно, особенно если шаблон сложный

## СОЗДАНИЕ РЕГУЛЯРНОГО ВЫРАЖЕНИЯ ##

* с помощью конструктора:

		const regex = new RegExp("pattern", "flags");

* «pattern» — это строка, содержащая регулярное выражение
* «flags» — дополнительные флаги, определяющие, как будет работать регулярное выражение. Например, флаг i указывает, что регулярное выражение должно игнорировать регистр символов

* этот способ предпочтительнее, когда известно, что выражение будет изменяться или шаблон не известен. Например, это информация, которую вводит пользователь в формах

* с помощью литералов:
		const regex = /pattern/flags;

* первая часть — шаблон, который необходимо описать, он заключается в слеши (//)
 вторая часть, после закрывающего слеша, — флаги (использование необязательно)

## ШАБЛОНЫ И МЕТАСИМВОЛЫ ##

* шаблоны — набор символов, которые используют для поиска определённых сочетаний символов в тексте
* метасимволы — специальные символы, которые используют для составления шаблонов

"."— соответствует любому одиночному символу, кроме символа новой строки
"*"— соответствует нулю или более повторениям предыдущего символа
"+"— соответствует одному или более повторениям предыдущего символа
"?"— соответствует нулю или одному повторению предыдущего символа
"^"— соответствует началу строки
"$"— соответствует концу строки
"()" — определяет группу символов, которые могут быть повторены

## КВАНТИФИКАТОРЫ И МОДИФИКАТОРЫ ##

### квантификаторы ###

* квантификаторы — метасимволы, которые определяют количество повторений предыдущего символа

{n} — соответствует ровно n повторениям предыдущего символа
{n,m} — соответствует от n до m повторений предыдущего символа
{n,} — соответствует n или более повторениям предыдущего символа
? — делает предыдущий квантификатор ленивым, т. е. соответствует наименьшему возможному количеству повторений

* Пример использования квантификатора:

		const pattern = /a{3}/; // соответствует трём символам "a" подряд

* в тексте, который будет обрабатываться с помощью этого регулярного выражения, будут найдены все вхождения трёх символов "a" подряд
* например, строка «baaaad» будет соответствовать шаблону, а строка «abaa» — нет.

### модификаторы ###
* модификаторы — специальные флаги, которые можно добавить к регулярному выражению для изменения его поведения

* некоторые модификаторы:

g — глобальный поиск, ищет все совпадения в строке
i — игнорирование регистра, игнорирует различия между верхним и нижним регистром
m — многострочный поиск, позволяет искать совпадения в нескольких строках

* пример использования модификатора:

		const pattern = /test/gi; // соответствует строкам "test" или "Test" или "TEST" глобально и без учёта регистра

## ГРУППЫ И ОБРАТНЫЕ ССЫЛКИ ##

* группы — это последовательности символов, заключённые в скобки (), которые могут повторяться с помощью квантификаторов
* группы также позволяют использовать обратные ссылки, которые ссылаются на результат совпадения группы в регулярном выражении
* обратная ссылка обозначается символом \ и номером группы, например, \1 ссылается на первую группу

* пример использования групп и обратных ссылок:

		​​const pattern = /(\w+)\s\1/; // соответствует повторяющейся последовательности символов, разделённой пробелом

* в этом примере группа (\w+) соответствует любой последовательности символов, состоящей из буквенно-цифровых символов и подчёркивания
* затем \s соответствует пробелу, а \1 обратно ссылается на первую группу (\w+), так что регулярное выражение соответствует только тем строкам, в которых последовательность символов повторяется через пробел

## ЭКРАНИРОВАНИЕ В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ
* в регулярках есть символы, которые имеют специальное значение и используются для обозначения шаблонов, таких как поиск символов, чисел и т. д. Но иногда возникают ситуации, когда эти символы должны быть экранированы — использованы как обычные символы, вместо своего специального значения.

* для экранирования символа используется обратный слеш \

* например, символ . в регулярном выражении означает любой символ, но если мы хотим использовать точку как обычный символ, мы можем экранировать его, написав

			\.

## ИСПОЛЬЗОВАНИЕ РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ С МЕТОДАМИ ОБЪЕКТА RegExp и String ##

### Метод test() ###

* метод test() проверяет, соответствует ли регулярное выражение заданной строке. Метод возвращает true, если строка соответствует регулярному выражению, и false, если не соответствует

		let str = "Hello, world!";
		const pattern = /Hello/;

		if (pattern.test(str)) {
			console.log("String contains 'Hello'");
		} else {
			console.log("String does not contain 'Hello'");
		}

* в этом примере мы используем метод test() для проверки, содержит ли строка str подстроку «Hello»
* регулярное выражение /Hello/ соответствует строке «Hello», и метод test() вернёт true

### Метод exec() ###
* метод exec() используется для поиска совпадений регулярного выражения в заданной строке
* метод возвращает массив, содержащий найденное совпадение и дополнительную информацию о нём

		let str = "Hello, world!";
		const pattern = /Hello/;

		let result = pattern.exec(str);

		console.log(result); // ["Hello", index: 0, input: "Hello, world!"]

* метод exec() возвращает массив, содержащий найденное совпадение «Hello», индекс первого символа совпадения в исходной строке и саму исходную строку

### Метод match() ###
* метод match() используется для поиска всех совпадений регулярного выражения в заданной строке
* метод возвращает массив, содержащий все найденные совпадения

		let str = "The quick brown fox jumps over the lazy dog.";
		const pattern = /the/gi;

		let result = str.match(pattern);

		console.log(result); // ["the", "the"]

* метод match() возвращает массив, содержащий все найденные совпадения, включая повторения


### Метод replace() ###

* метод replace() принимает два аргумента: регулярное выражение и строку, на которую нужно заменить найденное совпадение
* этот метод ищет все совпадения с заданным регулярным выражением в исходной строке и заменяет их на указанную строку

		let str = "Привет, мир!";
		const pattern = /мир/;

		let newstr = str.replace(pattern, "земля");

		console.log(newstr); // "Привет, земля!"

* регулярное выражение /мир/ ищет все совпадения со словом «мир» в строке, и метод replace() заменяет их на слово «земля»
* результатом работы метода является новая строка «Привет, земля!»


### Метод search() ###

* метод search() принимает один аргумент — регулярное выражение
* он ищет первое совпадение с заданным регулярным выражением в исходной строке и возвращает индекс первого символа совпадения
* если совпадение не найдено, метод возвращает -1

		let str = "Это текст для примера";
		const pattern = /текст/;

		let index = str.search(pattern);

		console.log(index); // 4

* в этом примере мы используем метод search() для поиска первого совпадения со словом «текст» в строке «Это текст для примера»
* регулярное выражение /текст/ ищет первое совпадение со словом «текст» в строке, и метод search() возвращает индекс первого символа этого совпадения, который равен 4


### Метод split() ###

* метод split() принимает один аргумент — регулярное выражение
* он разбивает исходную строку на массив подстрок, используя заданное регулярное выражение как разделитель

		let str = "Это текст для примера";
		const pattern = / /;

		let words = str.split(pattern);

		console.log(words); // ["Это", "текст", "для", "примера"]

* в этом примере мы используем метод split() для разделения строки «Это текст для примера» на массив слов, используя регулярное выражение / / в качестве разделителя
* регулярное выражение / / ищет все пробелы в строке, и метод split() использует их в качестве разделителя для разделения строки на массив слов
* результатом работы метода является массив [«Это», «текст», «для», «примера»]

