# 9.18. Тестирование слайса gameProcess

# 9.8. Добавление тестов для слайса gameProcess

- редьюсер - это чистая функция, на вход мы передаём начальное или текущее значение состояния и действие
- в результате выполнения этой функции нам должно вернуться новое состояние

- создадим файл с тестами
- начнём с объявления группы тестов функцией describe с названием 'GameProcess Slice'

- что мы будем тестировать в самом начале:
- мы должны убедиться, у нас создаётся слайс gameProcess и мы передаём ему initialState
- если мы передадим какой-то неизвестный или пустой action, то редьюсер должен вернуть это начальное состояние

- опишем тестовый случай 'should return initial state with empty action'
- начнём со стадии подготовки
- создадим пустой action

```ts
const emptyAction = { type: '' };
```

- теперь опишем state, который ожидаем получить в результате работы нашего редьюсера

```ts
const expectedState = { mistakes: 333, step: 10 };
```

- значения полей могут быть любыми

- результатом выполнения createSlice является объект, а как нам добраться до редьюсера?
- при экспорте мы указываем все действия, которые создаются в результате создания слайса
- аналогичное свойство есть и для редьюсера - reducer
- в файл теста импортируем сам слайс, а затем обратимся к свойству reducer

```ts
const result = gameProcess.reducer();
```

- в редьюсер передаём объект состояния expectedState и emptyAction

```ts
const result = gameProcess.reducer(expectedState, emptyAction);
```

- теперь сравним

```ts
expect(result).toEqual(expectedState);
```

- код тестового случая полностью:

```ts
it('should return initial state with empty action', () => {
  const emptyAction = { type: '' };
  const expectedState = { mistakes: 333, step: 10 };

  const result = gameProcess.reducer(expectedState, emptyAction);

  expect(result).toEqual(expectedState);
});
```

- сделаем ещё один тест, в котором проверим, что нам будет возвращено состояние по умолчанию, если мы ничего не передадим (передадим undefined) в редьюсер аргументом
- опишем тестовый случай 'should return default initial state with empty action and undefined state'
- на стадии подготовки объявим emptyAction и expectedState

```ts
const emptyAction = { type: '' };
const expectedState = { mistakes: 0, step: FIRST_GAME_STEP };
```

- этот объект expectedState является таким же по форме как и объект initialState данного слайса (но мы его не можем импортировать из слайса, поэтому дублируем)
- если initialState поменяется, то тест сломается
- опишем стадию действия

```ts
const result = gameProcess.reducer(undefined, emptyAction);
```

- опишем стадию проверки и убедимся, что result === expectedState

```ts
expect(result).toEqual(expectedState);
```

## проверка действий

- наш слайс предусматривает взаимодействие с несколькими действиями incrementStep, checkUserAnswer, resetGame
- начнём с resetGame
- опишем тестовый случай 'should reset game with "resetGame" action'

```ts
it('should reset game with "resetGame" action', () => {
  // опишем объект с начальным состоянием:
  const initialState = { mistakes: 333, step: 10 };
  // опишем объект, который ожидаем получить в результате выполнения действия:
  const expectedState = { mistakes: 0, step: FIRST_GAME_STEP };

  // результат выполнения при передаче начального состояния и действия сброса игры
  const result = gameProcess.reducer(initialState, resetGame);

  // опишем сравнение
  expect(result).toEqual(expectedState);
});
```

- протестируем действие incrementStep
- при действии incrementStep увеличивается значение поля step в объекте состояния
- опишем тестовый случай

```ts
it('should increment step with "incrementStep" action', () => {
  const initialState = { mistakes: 333, step: 4 };
  const expectedStep = 5;

  const result = gameProcess.reducer(initialState, incrementStep);

  expect(result.step).toBe(expectedStep);
});
```

- напишем тест для проверки того, что при правильном ответе количество ошибок не увеличивается

```ts
it('should not increment mistake count with "checkUserAnswer" action and correct answer', () => {
  // начальное (текущее) состояние:
  const initialState = { mistakes: 0, step: 4 };

  // значение, которое мы ожидаем получить:
  const expectedMistakeCount = 0;

  // подготовим фейковый вопрос:
  const question = makeFakeArtistQuestion();

  // получаем правильный ответ, опираясь на свойство song
  const { artist: userAnswer } = question.song;

  const result = gameProcess.reducer(
    initialState,
    checkUserAnswer({ question, userAnswer })
  );

  expect(result.mistakes).toBe(expectedMistakeCount);
});
```

- убедимся, что если ответ неправильный, то количество ошибок увеличивается:

```ts
it('should increment mistake count with "checkUserAnswer" action and not correct answer', () => {
  const initialState = { mistakes: 0, step: 4 };
  const expectedMistakeCount = 1;
  const question = makeFakeArtistQuestion();
  const userAnswer = 'unknown artist';

  const result = gameProcess.reducer(
    initialState,
    checkUserAnswer({ question, userAnswer })
  );

  expect(result.mistakes).toBe(expectedMistakeCount);
});
```

- весь модуль:

```ts
import { FIRST_GAME_STEP } from '../../const';
import { makeFakeArtistQuestion } from '../../utils/mocks';
import { checkUserAnswer, gameProcess, incrementStep, resetGame } from './game-process';

describe('GameProcess Slice', () => {
  it('should return initial state with empty action', () => {
    const emptyAction = { type: '' };
    const expectedState = { mistakes: 333, step: 10 };

    const result = gameProcess.reducer(expectedState, emptyAction);

    expect(result).toEqual(expectedState);
  });

  it('should return default initial state with empty action and undefined state', () => {
    const emptyAction = { type: '' };
    const expectedState = { mistakes: 0, step: FIRST_GAME_STEP };

    const result = gameProcess.reducer(undefined, emptyAction);

    expect(result).toEqual(expectedState);
  });

  it('should reset game with "resetGame" action', () => {
    const initialState = { mistakes: 333, step: 10 };
    const expectedState = { mistakes: 0, step: FIRST_GAME_STEP };

    const result = gameProcess.reducer(initialState, resetGame);

    expect(result).toEqual(expectedState);
  });

  it('should increment step with "incrementStep" action', () => {
    const initialState = { mistakes: 333, step: 4 };
    const expectedStep = 5;

    const result = gameProcess.reducer(initialState, incrementStep);

    expect(result.step).toBe(expectedStep);
  });

  it('should not increment mistake count with "checkUserAnswer" action and correct answer', () => {
    const initialState = { mistakes: 0, step: 4 };
    const expectedMistakeCount = 0;
    const question = makeFakeArtistQuestion();
    const { artist: userAnswer } = question.song;

    const result = gameProcess.reducer(
      initialState,
      checkUserAnswer({ question, userAnswer })
    );

    expect(result.mistakes).toBe(expectedMistakeCount);
  });

  it('should increment mistake count with "checkUserAnswer" action and not correct answer', () => {
    const initialState = { mistakes: 0, step: 4 };
    const expectedMistakeCount = 1;
    const question = makeFakeArtistQuestion();
    const userAnswer = 'unknown artist';

    const result = gameProcess.reducer(
      initialState,
      checkUserAnswer({ question, userAnswer })
    );

    expect(result.mistakes).toBe(expectedMistakeCount);
  });
});
```
