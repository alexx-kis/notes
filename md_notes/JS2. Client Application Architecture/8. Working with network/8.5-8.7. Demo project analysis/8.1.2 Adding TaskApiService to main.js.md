# 8.1.2 Добавление модуля TaskApiService в точке входа

- чтобы модель могла взаимодействовать с `TaskApiService`, нам нужно его инициализировать - создать экземпляр класса `TaskApiService`, потом как-то его прокинуть в модель

- можно сделать это внутри модели, но это не очень хорошая идея, потому что тогда модель становится жёстко завязанной на `TaskApiService`, лучше передать это в модель в качестве зависимости, например, в конструктор

- в `main.js` подключаем `TaskApiService` и заводим две константы: AUTHORIZATION и END_POINT

- не нужно писать генератор для строки авторизации, можно просто придумать, но важно не копировать её из ТЗ, чтобы она не была у всех одинаковая

- в `END_POINT` определяем адрес сервера, от которого будем строить маршрут

```js
import TasksApiService from './tasks-api-service.js';

const AUTHORIZATION = 'Basic hS2sfS44wcl1sa2j';
const END_POINT = 'https://22.objects.pages.academy/task-manager';
```

### передача информации от сервера в модель

- это делается через конструктор
- передаём в модель объект, в котором указываем `taskApiService` со значением экземпляр `TaskApiService`, в который и передаём токен авторизации и `END_POINT`

```js
const tasksModel = new TasksModel({
  tasksApiService: new TasksApiService(END_POINT, AUTHORIZATION),
});
```

### что изменяется в модели

- в конструкторе нужно предусмотреть параметр `taskApiService`, через который мы будем передавать зависимость

- в конструкторе применяем сразу деструктуризацию
- сохраняем в приватное свойство `#tasksApiService`
- затем в конструкторе пробуем выполнить запрос к серверу, чтобы получить данные
- обращаемся к нашему сервису, обращаемся к его геттеру задач, он вернёт промис, и тут можно что-то сделать, пока выведем в консоль

```js
export default class TasksModel extends Observable {
  #tasksApiService = null;
  #tasks = Array.from({ length: TASK_COUNT }, getRandomTask);

  constructor({ tasksApiService }) {
    super();
    this.#tasksApiService = tasksApiService;

    this.#tasksApiService.tasks.then((tasks) => {
      console.log(tasks);
      // Есть проблема: структура объекта похожа, но некоторые ключи называются иначе,
      // а ещё на сервере используется snake_case, а у нас camelCase.
      // Можно, конечно, переписать часть нашего клиентского приложения, но зачем?
      // Есть вариант получше - паттерн "Адаптер"
    });
  }

  //...
}
```

- с сервера некоторые ключи объектов могут приходить не в таком же формате, как нам нужно, например, в snake_case

- для выполнения этого домашнего задания нужно не забывать про вкладку браузера `network`, чтобы понять, отправляется ли запрос и что возвращает сервер
