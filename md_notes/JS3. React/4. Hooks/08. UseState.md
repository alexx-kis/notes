# Хук useState

— это один из основных хуков React, который позволяет добавлять локальное состояние в функциональные компоненты

## Что такое useState?

- `useState` — это функция, которая добавляет в функциональный компонент возможность управлять состоянием
- Она возвращает массив из двух значений:

  1. Текущее состояние: переменная, которая хранит текущее значение состояния
  2. Функция обновления состояния: функция, с помощью которой вы можете изменить состояние и запустить повторную отрисовку компонента

```jsx
const [state, setState] = useState(initialState);
```

- state — текущее значение состояния
- setState — функция для обновления состояния
- initialState — начальное значение состояния, может быть любого типа: строка, число, объект, массив, булево значение или функция

## Особенности useState

### Начальное состояние:

- При первом рендеринге компонента React использует значение `initialState` для установки состояния
- Если передать функцию в `useState`, эта функция будет вызвана один раз (только при инициализации состояния)
- Это полезно для вычисления сложного начального состояния

```jsx
const [count, setCount] = useState(() => computeInitialValue());
```

### Обновление состояния:

- Обновление состояния через setState вызывает повторный рендеринг компонента
- Вы можете передать:
  - Новое значение состояния:

```jsx
setCount(5); // Обновит count до 5
```

- Функцию-обновление: она принимает текущее состояние и возвращает следующее.

```jsx
setCount((prevCount) => prevCount + 1);
```

### Асинхронность обновлений:

- React группирует вызовы `setState` для оптимизации рендеринга, поэтому обновление состояния может быть отложено
- Переменная состояния сразу после вызова setState не обновится:

```jsx
setCount(5);
console.log(count); // Все еще предыдущее значение
```

### Частичное обновление недоступно:

- В отличие от классовых компонентов, где `setState` объединяет старое состояние с новым, useState полностью заменяет состояние
- Поэтому важно вручную объединять объекты/массивы

### Пакетное обновление (batching):

- В React обработчики событий объединяются в одну группу обновлений
- Это помогает избежать лишних перерисовок

```jsx
setCount((prev) => prev + 1);
setCount((prev) => prev + 1);
// count увеличится на 2, несмотря на два вызова setCount
```

## Когда использовать useState?

- Используйте `useState` в следующих случаях:

1. Для отслеживания локального состояния компонента:

- Числа (счётчики, индексы)
- Булевы значения (например, переключатели, состояния кнопок)
- Строки (поля ввода)
- Объекты и массивы (списки задач, формы)

2. Когда состояние не зависит от других компонентов и не должно быть глобальным

## Ограничения и предостережения

- Хук нельзя вызывать внутри условий или циклов

- Хуки должны вызываться на верхнем уровне компонента, чтобы React мог корректно управлять порядком вызовов хуков

```jsx
if (someCondition) {
  const [state, setState] = useState(false); // Ошибка!
}
```

- Обновление состояния не изменяет переменную немедленно

- Используйте функции-обновления, если новое состояние зависит от предыдущего:

```jsx
setCount((prevCount) => prevCount + 1);
```

### Повторные вызовы функций-инициализаторов

- В режиме строгой проверки (StrictMode) React вызывает функцию-инициализацию (() => createTodos()) дважды
- Убедитесь, что она чистая

### Мутация объектов и массивов запрещена

- Состояние должно быть иммутабельным
- Для обновления создавайте новые копии объектов/массивов

## Общие сценарии использования

1. Счётчик

- Самый простой пример использования useState

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы кликнули {count} раз</p>
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}
```

2. Форма с несколькими состояниями

- Для каждого поля создаётся отдельное состояние

```jsx
import { useState } from 'react';

function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  return (
    <form>
      <input value={name} onChange={(e) => setName(e.target.value)} placeholder='Имя' />
      <input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder='E-mail'
      />
      <p>Имя: {name}</p>
      <p>E-mail: {email}</p>
    </form>
  );
}
```

3. Сложные структуры данных

- Для работы с массивами и объектами используются spread-операторы

- Объекты:

```jsx
function Form() {
  const [form, setForm] = useState({ name: '', email: '' });

  const handleChange = (e) => {
    setForm({
      ...form,
      [e.target.name]: e.target.value,
    });
  };

  return (
    <form>
      <input name='name' value={form.name} onChange={handleChange} placeholder='Имя' />
      <input
        name='email'
        value={form.email}
        onChange={handleChange}
        placeholder='E-mail'
      />
      <p>Имя: {form.name}</p>
      <p>E-mail: {form.email}</p>
    </form>
  );
}
```

- Массивы:

```jsx
function TodoApp() {
  const [todos, setTodos] = useState([]);

  const addTodo = (todo) => {
    setTodos([...todos, todo]); // Добавление нового элемента
  };

  const removeTodo = (index) => {
    setTodos(todos.filter((_, i) => i !== index)); // Удаление элемента
  };

  return (
    <div>
      <button onClick={() => addTodo(`Задача ${todos.length + 1}`)}>
        Добавить задачу
      </button>
      <ul>
        {todos.map((todo, index) => (
          <li key={index}>
            {todo}
            <button onClick={() => removeTodo(index)}>Удалить</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## Когда не использовать useState

- Если состояние нужно в нескольких компонентах или оно должно быть глобальным, рассмотрите использование useReducer, контекста (Context API) или глобального хранилища (Redux, Zustand и др.)
- `useState` лучше подходит для простого локального состояния
