# Fetch API #

* Fetch API — современный, гибкий и универсальный способ для отправки запросов к серверу
* Мы говорим Fetch API, но по факту подразумеваем функцию fetch(), с помощью которой можно получать и отправлять произвольные данные на сервер

## Синтаксис ##
* Функция принимает два параметра: адрес ресурса, на который требуется отправить запрос, и объект с настройками. Второй параметр опционален и может не использоваться:

		fetch(адрес[, настройки]);
        
      
* Результатом выполнения fetch() станет промис
* За счёт поддержки промисов, обрабатывать результат выполнения fetch() становится гораздо удобнее
* Попробуем проверить на реальном примере
* Запросим информацию о публикациях у тестового сервера JSONPlaceholder с помощью fetch():

		fetch('https://jsonplaceholder.typicode.com/posts')
			.then((response) => response.json())
			.then((posts) => console.log(posts));
      
* Этот простой пример демонстрирует выполнение GET-запроса для получения данных (список публикаций) в JSON
* Первым аргументом fetch() мы передали адрес ресурса
* Второй аргумент не задали, так как для выполнения GET-запроса дополнительные настройки не требуются - по умолчанию fetch() выполнит именно GET-запрос

* Раз fetch() возвращает промис, мы получаем возможность использовать знакомые методы then, catch и finally
* В случае успешного завершения промиса мы получим от сервера объект с ответом
* Само собой не в текстовом виде, а в структурированном. Объект позволит понять состояние ответа и получить не только данные из тела ответа, но и при необходимости служебную информацию, например, заголовки, установленные сервером

* Ещё раз, fetch() не привносит магии — взаимодействие с сервером по-прежнему происходит в асинхронном режим
* Это означает, что запрос выполнится не мгновенно, а данные мы получим не сразу, результатом выполнения fetch() будет промис в состоянии выполняется

*  В представленном примере нас интересуют только данные
* Результат выполнения fetch() — ответ от сервера — попадёт в параметр response (это специальный объект ответа, о нём будет дальше)
*  Нам заранее известно, что сервер вернёт информацию о публикациях в JSON
* Поэтому мы не делаем дополнительных проверок, а сразу пытаемся прочитать JSON, для этого используем метод json() у объекта с ответом:

		.then((response) => response.json())

* Встроенный метод json() автоматически извлечёт JSON-данные из ответа, преобразует их в объект или массив, чтобы с данными можно было работать в JavaScript, и вернёт новый промис
* А раз результатом станет промис, то можно продолжать цепочку then и вывести данные в консоль:

		.then((posts) => console.log(posts));
    
      
* Попробуйте скопировать код целикового примера и выполнить на этой странице в консоли браузера. Спустя какое-то время в консоли появится список публикаций

![alt text](https://up.htmlacademy.ru/assets/intensives/javascript/31/book/network/fetch/01-fetch.png)

Рисунок 1. Результат выполнения fetch


## Объект ответа (Response) ##

* Объект ответа (Response) мы получаем при завершении промиса
* В этом объекте хранится вся информация об ответе сервера: заголовки, статусы, результат выполнения запроса и другая служебная информация

### Объект ответа — не всегда данные ###

* Сервер может исполнить не все запросы
* Самая банальная ситуация: запрашиваемый ресурс не найден, это может случиться по разным причинам: ресурс был, но потом его перенесли в другое место или в адресе была допущена ошибка, на такой запрос сервер ответит кодом 404

* Возникает вопрос: «А как понять статус выполнения запроса?» Ведь если сервер вернул 404, то нет никакого смысла пытаться извлечь JSON, данных ведь нет
* При этом промис не будет завершён с ошибкой, ведь сервер ответил, а значит перехватить такую ситуацию с помощью catch не получится

* Определить успешность выполнения запроса поможет свойство объекта ответа ok
* Оно содержит булево значение: если запрос выполнен успешно, ok будет true, в противном случае false

* Звучит не сложно, но возникает другой вопрос: «А что подразумевается под успехом выполнения?»
* Успех определяется на основании кода ответа сервера на запрос
* Если код ответа в диапазоне чисел 200-299, значит он выполнился успешно, ответы с кодами, которые не попадают в диапазон, означают выполнение запроса с ошибкой

* Немного доработаем пример получения списка публикаций - добавим в него проверку успешности выполнения запроса:

		// Для проверки обработки ошибки изменим часть адреса,
		// заведомо указав несуществующий адрес /posts1
		fetch('https://jsonplaceholder.typicode.com/posts1')
			.then((response) => {
				if (response.ok) {
					return response;
				}

				throw new Error(`${response.status} — ${response.statusText}`);
			})
			.then((response) => response.json())
			.then((posts) => console.log(posts))
			.catch((error) => console.log(error));

* Код примера немного подрос, но мы не потеряли в читабельности
* В первом then выполняется проверка свойства ok, если оно равно true, значит серверу есть, чем ответить, можно возвращать объект ответа и продолжать конвейер обработки (обработать JSON и так далее)

* Если значение ok равно false, серверу нечем ответить, разумным решением в такой ситуации станет формирование объекта с ошибкой
* Для этого бросим исключение с Error, аргументами передадим значения свойств объекта ответа status (код ответа сервера) и statusText (пояснительная строка)

* Как только будет брошено исключение, оно переведёт промис в состояние завершён с ошибкой, и мы сможем перехватить его в catch, чтобы вывести в консоль содержимое ошибки

![alt text](https://up.htmlacademy.ru/assets/intensives/javascript/31/book/network/fetch/02-fetch-catch.png)

Рисунок 2. Обработка ошибки

* Если ошибку вернул не сервер, а, например, в момент запроса пропал интернет, в такой ситуации промис, возвращаемый fetch(), будет завершён с ошибкой. Следовательно, обработать такую ситуацию можно в методе catch. Поэтому не забывайте добавлять его в конце цепочки then!

## Отправка информации на сервер ##

* Работа с fetch() не ограничивается лишь получением данных от сервера, ничего не мешает их передавать на сервер
* Эта задача не сильно сложнее, но придётся задействовать второй аргумент fetch() — объект с настройками

* Попробуем подготовить и отправить запрос методом POST (речь о методе в контексте протокола HTTP):

		// Данные для отправки
		const post = {
			userId: 31337,
			title: 'Обзор метода fetch',
			body: 'Содержимое обзора',
		};

		// Вторым аргументом передадим объект с настройками.
		// Определим в нём метод, заголовки и тело запроса
		fetch(
			'https://jsonplaceholder.typicode.com/posts',
			{
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(post),
			})
			.then((response) => response.json())
			.then((json) => console.log(json));

![alt text](https://up.htmlacademy.ru/assets/intensives/javascript/31/book/network/fetch/03-post.png)

Рисунок 3. Результат отправки данных методом POST

* В этом примере кода задействован второй аргумент fetch()
* С его помощью мы передаём объект с настройками, где переопределяем HTTP-метод (по умолчанию GET, а нам нужен POST)

* При подготовке запроса нам доступна возможность установить произвольные заголовки
* Для этого в объекте с настройками предусмотрено свойство headers
* Это обычный объект, где каждая пара ключ-значение описывает заголовок
* В приведённом примере определяем один заголовок — Content-Type (тип содержимого)
* Данные передаются в формате JSON, ему соответствует тип application/json
* Другие заголовки добавляются аналогичным образом
* Например, если потребуется добавить заголовок User-Agent, то достаточно описать ещё одну пару ключ-значение:

		headers: {
			'Content-Type': 'application/json',
			'User-Agent': 'Google Chrome'
		},  
      
* Тело запроса фиксируется в свойстве body
* Мы планируем отправить данные в JSON, поэтому сразу превращаем подготовленный объект с данными в JSON с помощью JSON.stringify()
* Дальше всё повторяется: пишем код для обработки ответа, возможной ошибки и т. д.

## Резюме ##
* fetch() — это современный способ отправки запросов с клиента к серверу
* В простых случаях можно обойтись буквально одной строчкой кода, а за счёт поддержки промисов обработка ответов также упрощается и превращается в последовательную цепочку