# Оптимизация загрузки #

* на скорость загрузки страницы влияет количество данных, передаваемых при загрузке сайта
1. HTML код с текстом
2. файлы CSS
3. JS
4. изображения

* ресурсы, потребляемые сайтом:
1. процессорное время - это время, за которое процессор выполнит скрипт. чем дольше процессор будет выполнять скрипт, тем дольше будет грузиться страница
2. оперативная память
3. нагрузка на интернет-канал



## оптимизация повторных операций ##
* вызов одной и той же функции для одной и той же цели несколько раз
          
        const path = 'img.png';

        if (path.slice(-4) === '.png' || path.slice(-4) 
          === '.jpg') { 
          console.log('+++');
        } else {
          console.log('---');
        }

* здесь функция slice вызывается два раза, правильнее было бы выполнить отрезание строки один раз и результат записать в переменную

        const path = 'img.png';
        const ext  = path.slice(-4);

        if (ext === '.png' || ext === '.jpg') {
          console.log('+++');
        } else {
          console.log('---');
        }



## оптимизация лишних проходов цикла ##
* В следующем коде проверяется, есть ли в массиве число 3:

        const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        const exists = false;

        for (let elem of arr) {
          if (elem === 3) {
            exists = true;
          }
        }

        console.log(exists);

* проблема в том, что после того, как определено, что число 3 есть в массиве, цикл всё равно продолжает крутиться до конца массива

* нерациональнее всего будет, если число 3 найдется где-то в начале массива, а сам массив будет длиной 1000 элементов, получится тысяча бесполезных лишних итераций цикла -  не оптимально

        const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        const exists = false;

        for (let elem of arr) {
          if (elem === 3) {
            exists = true;
            break;              // вовремя остановим цикл
          }
        }

        console.log(exists);



## оптимизация через использование встроенных функций ##

* пусть проверяется, есть ли в массиве число 3:

        const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        const exists = false;

        for (let elem of arr) {
          if (elem === 3) {
            exists = true;
            break;
          }
        }

        console.log(exists);

* дело в том, что встроенные в JavaScript функции всегда работают быстрее аналогичного самописного кода

* в нашем случае существует функция <i>includes()</i>, решающая поставленную задачу, - и пользоваться нужно именно этой функцией:

        const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        console.log(arr.includes(3));


* мораль: перед решением задачи нужно обязательно проверить, нет ли для её решения встроенной функции JavaScript


## выбор оптимального алгоритма ##

* иногда проблема кода бывает связана с тем, что выбрано не самое оптимальное решение задачи

* пусть нужно найти сумму целых чисел от 1 до 1000000:

        const sum = 0;

        for (let i = 1; i <= 1000000; i++) {
          sum += i;
        }
          
        console.log(sum);
        
* дело в том, что для решения поставленной задачи существует математическое решение:

* это решение практически не требует ресурсов! Запрограммируем его:

        const n = 1000000;
        const sum = n * (n + 1) / 2;
        console.log(sum);

* мораль: перед решением ресурсоёмкой задачи обязательно нужно проверить, нет ли для её решения готовой математической формулы или готового математического подхода


### Оптимизация использования регулярных выражений
* регулярные выражения - очень тяжёлая и относительно медленно работающая штука
* когда есть альтернативное решение, желательно пользоваться именно им

* пусть нужно проверить, начинается ли некоторая строка на восклицательный знак

        const str = '!123';

        if (/^!/.test(str)) {
          console.log('+++');
        } else {
          console.log('---');
        }

* однако, такая задача имеет гораздо более быстро работающее решение:

        const str = '!123';

        if (str[0] == '!') {
          console.log('+++');
        } else {
          console.log('---');
        }



### Оптимизация работы с DOM ###

* работа с DOM это медленная операция, поэтому нужно сводить к минимуму получение элементов, чтение и запись данных, особенно в цикле

* пусть есть инпут, в который вводится число:

        <input>
* давайте при потере фокуса проверим, что введенное число находится в заданном диапазоне:

        const input = document.querySelector('input');

        input.addEventListener('blur', function() {
          if (+input.value > 0 && +input.value <= 10) {
            console.log('+++');
          } else {
            console.log('---');
          }
        });

* проблема в том, что мы два раза прочитываем текст из инпута, хотя число в нём не меняется - не оптимально

        let input = document.querySelector('input');

        input.addEventListener('blur', function() {
          let num = +input.value;                 // сохраним число в переменную
          
          if (num > 0 && num <= 10) {
            console.log('+++');
          } else {
            console.log('---');
          }
        });



### Оптимизация обработчиков событий ###

* чрезмерно много обработчиков, навешанных на элементы съедают много оперативной памяти и приводят к подвисанию страницы

* например, пусть у нас есть некоторый список:

        <ul></ul>

* получим ссылку на этот список в переменную:

        let ul = document.querySelector('ul');

* заполним теперь наш список тегами li, навесив на них обработчик клика:

        for (let i = 1; i <= 1000; i++) {
          let li = document.createElement('li');
          li.textContent = i;
          ul.append(li);
          
          li.addEventListener('click', function() {
            console.log(this.textContent);
          });
        }

* в итоге получается, что у нас 1000 обработчиков - это очень много
* для оптимизации мы можем навесить только один обработчик на тег ul, воспользовавшись делегированием

* для начала просто создадим пункты списка:

        for (let i = 1; i <= 1000; i++) {
          let li = document.createElement('li');
          li.textContent = i;
          ul.append(li);
        }
* а теперь выполним делегирование обработчика событий:

        ul.addEventListener('click', function(event) {
          let li = event.target.closest('li');
          
          if (li) {
            console.log(li.textContent);
          }
        });