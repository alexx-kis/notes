# 6.2. Иммутабельность

- Иммутабельность — это концепция, в которой данные нельзя изменить после их создания

- Это свойство имеет множество применений в программировании, особенно в контексте управления состоянием приложения и его предсказуемости

### Примеры иммутабельности:

- Примитивы в JavaScript, такие как числа или строки, являются иммутабельными:

```js
let x = 3;
const y = x;

x = 5;
y; // 3
```

- Здесь изменение переменной x не влияет на значение переменной y, потому что примитивы передаются по значению

- Объекты в JavaScript, напротив, являются мутабельными:

```js
const x = { a: 1 };
const y = x;

x.a = 2;
y; // {a: 2}
```

- Поскольку объекты передаются по ссылке, изменение в объекте x также отразится на объекте y

## Зачем нужна иммутабельность?

- Иммутабельность помогает избежать непредсказуемого поведения, особенно когда данные могут быть изменены в разных частях приложения

- Это обеспечивает контроль над тем, где и как можно изменять состояние, и позволяет избежать «побочных эффектов», таких как изменения данных по ссылке

#### Преимущества:

- **Упрощение откатов состояния:** Например, для реализации функции отката (Ctrl+Z) при каждом изменении сохраняется предыдущее состояние. Если данные мутабельны, сохранённые состояния могут быть изменены, что приведёт к ошибкам
- **Датабиндинг:** В модели с датабиндингом иммутабельность предотвращает неправильные изменения данных, позволяя системе чётко контролировать момент и способ их изменения, например через методы модели

## Реализация иммутабельности в JavaScript:

- const ограничивает изменение переменной, но не защищает вложенные свойства объектов

- Object.freeze предотвращает изменение свойств объекта, но не делает его «глубокой» заморозкой — вложенные объекты остаются изменяемыми.

```js
const object = {
  topProperty: 'Значение объекта',
  childObject: {
    deepProperty: 'Значение дочернего объекта',
  },
};

const freezedObject = Object.freeze(object);

freezedObject.topProperty = 'Другое значение'; // Ошибка
freezedObject.childObject.deepProperty = 'Другое значение'; // Работает
```

### Альтернативные подходы:

- **Copy On Write:** Создание независимой копии данных при каждом изменении.Простой и надёжный метод, но может быть дорогим с точки зрения памяти и производительности.

```js
const newState = state.map((item, index) => (index === 1 ? { ...item, name: 'Резиновая уточка' } : item));
```

- **Resource Sharing:** Копируются только изменённые части данных, а неизменённые — передаются по ссылке. Этот метод эффективнее по памяти и времени, но менее надёжен

```js
const newState = [...state];
newState[1] = { ...newState[1], name: 'Резиновая уточка' };
```

### Какой подход лучше зависит от ситуации:

- Copy On Write подходит для небольших состояний, где производительность не критична

- Resource Sharing лучше использовать в случаях, где критична производительность, особенно при работе с большими состояниями или частыми изменениями.

- В некоторых случаях можно комбинировать оба подхода, используя Copy On Write для отдельных частей состояния и Resource Sharing для остальной части приложения.
