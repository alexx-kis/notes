# 7.1 Использование паттерна Наблюдатель

- главная задача - прокачать модель, то есть мы должны отойти от использования презентера в качестве промежуточной модели, мы должны взаимодействовать с моделью напрямую

- когда у нас происходят какие-то изменения данных, мы должны всё это менять в модели, а не в свойстве, которое мы временно завели в презентере

- посмотрим на модель

```js
const TASK_COUNT = 22;

export default class TasksModel extends Observable {
  #tasks = Array.from({ length: TASK_COUNT }, getRandomTask);

  get tasks() {
    return this.#tasks;
  }
}
```

- пока есть только список задач, которые являются данными для отображения и есть один геттер, с помощью которого мы получаем эти задачи

- этот геттер мы используем только один раз в презентере

- то есть когда инициализируется `BoardPresenter` мы обращаемся к свойству модели `tasks` и получаем эти данные в свойство `#boardTasks` и дальше мы модель не трогаем

```js
  init() {
    this.#boardTasks = [...this.#tasksModel.tasks];
    //...
  }
```

- появляется проблема: так как у нас всё было в рамках одного презентера, нам было удобно, если что-то меняется, нам достаточно просто обновить одно свойство (`boardTasks`) в презентере, и мы можем скомандовать, что у нас данные поменялись и перерисовать представления

- это очень удобно, и не понятно, зачем что-то менять

- но тогда теряется сама идея модели, и мы столкнёмся со сложностями, если у нас данные должны меняться из нескольких мест, тогда будет работать через презентер неудобно, поэтому модель должна быть отделена

- нам нужно научить модель уведомлять об изменениях, то есть модель должна уметь сообщать, что у неё что-то поменялось

- для того, чтобы это сделать, воспользуемся паттерном наблюдатель

- так как нам не нужно его реализовывать, он уже реализован в виде класса `Observable` во фреймворке от Кекса

- отнаследуем модель `TaskModel` от класса `Observable`

- в связи с этим в модель попадают методы `addObserver()`, `removeObserver()`, `_notify()`

- в `BoardPresenter` заведём одноимённый геттер `get tasks()`, и он уже будет обращаться к свойству `tasks` у модели

```js
  get tasks() {
    return this.#tasksModel.tasks;
  }
```
- этот вариант удобен, потому что мы сможем в любом месте взаимодействовать с презентером и через него обратиться к модели

- мы сможем внутри презентера вызывать `get tasks()` и всегда получать актуальные данные из модели

- здесь можно будет также накрутить какую-то логику, например, сортировку, но позже

