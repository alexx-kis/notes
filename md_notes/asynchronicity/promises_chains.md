# Цепочки промисов #

### Метод then() ###

* чтобы получить результат завершённого промиса, нужно передать в метод then() две функции, которые впоследствии станут коллбэками resolve и reject:

		const myPromise = new Promise((resolve, reject) => {});

		myPromise.then(
			() => {}, // Станет resolve
			() => {}, // Станет reject
		);

* однако для передачи функции, которая станет коллбэком reject, есть другой способ

## Метод catch() ##

* аргументом ему нужно передать коллбэк для reject:

		const myPromise = new Promise((resolve, reject) => {});

		myPromise.then(() => {});
		myPromise.catch(() => {});

* однако так почти никто не пишет, так как в промисах можно использовать цепочки вызовов методов

		const myPromise = new Promise((resolve, reject) => {});

		myPromise.then(() => {}).catch(() => {});

* работает это так: первым вызывается метод then() у myPromise, вызов которого тоже возвращает промис, поэтому можно снова вызвать метод промиса catch()
* причём вызывать именно catch() необязательно, можно снова then():

		const myPromise = new Promise((resolve, reject) => {});

		myPromise.then(() => {}).then(() => {}).then(() => {}).catch(() => {});


## Метод finally() ##

* его используют, когда нужно выполнить функцию вне зависимости от того, завершился промис успешно или с ошибкой
* finally позволяет не дублировать один и тот же код в then() и catch():

const myPromise = new Promise((resolve, reject) => {});

		myPromise
			.then(() => {
				console.log('Промис завершён успешно');
		-    console.log('Спасибо за внимание');
			})
			.catch(() => {
				console.log('Промис завершён с ошибкой');
		-    console.log('Спасибо за внимание');
			})
		+  .finally(() => {
		+    console.log('Спасибо за внимание');
		+  });


## Цепочки промисов ##

### Синтаксис ###

* методы then(), catch(), finally() всегда возвращают новый промис
* за счёт этого можно строить цепочки вызовов методов промисов
* всё благодаря тому, что сперва then() вернул новый промис, а потом catch()

* цепочки необходимы для последовательного выполнения операций:

const breakfast = new Promise();

// Для простоты примера просто представим,
// что все функции, переданные в then, объявлены ранее

		breakfast
			.then(getOatmeal) // Находим крупу
			.then(getMilk) // Находим молоко
			.then(getButter) // Находим масло
			.then(shakeProducts) // Смешиваем всё в мультиварке
			.then(startMulticookerProgram) // Запускаем программу мультиварки
			.then(() => {}) // Последний then на случай успеха
			.catch(() => {}); // catch на случай ошибки в любом месте

* в таком коде можно легко определить последовательность действий
* как выполняется такой код:
первый then() вернёт новый промис. Затем мы снова вызываем then() и определяем коллбэк для resolve уже этого нового промиса. После мы повторяем этот алгоритм для всех остальных then() и, на случай ошибки где-то в цепочке, определяем коллбэк для catch()

* метод catch() описывается один раз в конце цепочки промисов
* если любой из вышестоящих промисов в цепочке будет завершён с ошибкой, то мы попадём в catch() и сможем обработать эту ситуацию, выполнение цепочки на этом прекратится
* если ошибка произошла в первом then(), то последующие then() выполняться не будут, инициативу перехватит catch()
* catch() перехватывает ошибки в цепочке только перед собой, поэтому, если нужно обработать все ошибки, то его нужно ставить в самый конец


### Результат предыдущего промиса в цепочке ###

* при построении цепочек из промисов мы получаем ещё одну возможность - передачу результата выполнения промиса вниз по цепочке
* это означает, что в каждом последующем then() можно получить результат выполнения коллбэка предыдущего then()

		// Объявляем промис sum и сразу успешно его завершаем с результатом 1
		const sum = new Promise((resolve) => resolve(1));

		sum
			.then((result) => result + 1) // Затем результат попадёт в then, где увеличивается на единицу и передаётся дальше
			.then((result) => result + 1) // И снова +1
			.then((result) => console.log(result)); // В итоге: 1 + 1 + 1 = 3

* каждый коллбэк, который мы описываем для then(), возвращает результат увеличения значения, полученного в виде параметра на единицу
* этот результат передаётся вниз по цепочке
* таким образом, в конце мы получаем 3
* эту возможность можно сравнить с конвейерной лентой


## Цепочки промисов на практике ##

* подход цепочек промисов используется довольно часто, например получение данных от сервера
* сначала мы должны получить данные (например в виде JSON строки), затем их десериализовать (прочитать), потом, возможно, нужно что-то в них добавить или удалить итд