# 5.1.5. Реализация логики обновления задачи

- для этого нам потребуется сделать отдельный обработчик, и после того как данные обновятся, нужно будет заново инициализировать `taskPresenter`

- в `BoardPresenter` заведём дополнительный приватный метод - `handleTaskChange()`

- здесь мы готовимся к обновлению задачи, то есть когда возникает `handleTaskChange()`, должна приходить обновлённая задача

- внутри этой функции мы должны обновить задачу в `boardTasks` (это копия задач из модели)

```js
  #handleTaskChange = (updatedTask) => {
    this.#boardTasks = updateItem(this.#boardTasks, updatedTask);
    this.#taskPresenters.get(updatedTask.id).init(updatedTask);
  };
```

- в этом массиве задач нужно найти нужную задачу и её обновить новыми данными

- для этого заводим вспомогательную функцию `updateItem()` и размещаем её в модуле `/utils/common`

```js
function updateItem(items, update) {
  return items.map((item) => item.id === update.id ? update : item);
}
```

- так как все задачи находятся в массиве, необходимо найти нужную задачу

- не всегда массив удобен для хранения данных, где приходится находить нужный объект по идентификатору или другому признаку, так как нужно будет постоянно итерироваться с условием

- итак, в функции `handleTaskChange()` находим новую задачу и просто её обновляем

- метод `updateItem` вернёт обновлённый массив

- затем нужно заново инициализировать презентер задачи, и для этого его нужно найти

- поэтому обращаемся к коллекции `taskPresenters`, находим презентер для обновлённой задачи с помощью метода `get()`, которому передаём ключ, по которому находим нужный презентер и вызываем сразу у этого презентера метод `init()`

```js
  #handleTaskChange = (updatedTask) => {
    this.#boardTasks = updateItem(this.#boardTasks, updatedTask);
    this.#taskPresenters.get(updatedTask.id).init(updatedTask);
  };
```
