## Промисы ##

* идея функций обратного вызова предельно проста и удобна в использовании, но с коллбэками легко случайно свернуть на шоссе «ад коллбэков» - код, в котором используется много-много вложенных функций обратного вызова
* Бороться с «адом коллбэков» можно несколькими способами:
	1. Реструктуризация кода
		- отказаться от пары коллбэков
		- функции, что останутся, вынести и записать в переменные
		- таким образом немного разгрузить основной код 
		- способ рабочий, но не сильно действенный, потому что провернуть такой трюк получается далеко не всегда
	2. Применение промисов
		- позволяют организовать асинхронный код по-другому: сделать его более плоским и последовательным, похожим на синхронный код

### Промис — это глобальный объект Promise
* Он позволяет отследить выполнение асинхронной операции и сохранить её результат 
* Сами асинхронные операции выполняются как и прежде: не сразу, а когда-нибудь
* Поэтому важно запомнить и уяснить, промисы — это не «магическая» замена асинхронных операций и не возможность получить результат такой операции сразу, это просто объект, позволяющий более эффективно работать с асинхронным кодом

### Синтаксис ###
* создать переменную, в которую присвоить экземпляр объекта Promise с помощью оператора new

		const myPromise = new Promise((resolve, reject) => {});

* аргументом в new Promise() нужно передать функцию-исполнитель (executor)
* у этой функции два параметра-коллбэка:
	- resolve - коллбэк, который нужно вызвать, если промис завершён успешно
	- reject - коллбэк, который нужно вызвать, если промис завершён с ошибкой

			const myPromise = new Promise((resolve, reject) => {
				if (2 > 1) {
					// Если всё верно, вызываем resolve, и тем самым объявляем, что myPromise завершён успешно
					resolve();
				} else {
					// Если в какой-то вселенной 2 не больше 1, вызываем reject, и тем самым объявляем, что myPromise завершён с ошибкой
					reject();
				}
			});

* Важно уточнить, что функцию-исполнитель браузер выполнит сразу

### Использование ###

* асинхронность внутри функции-исполнителя
* поскольку она вызывается сразу, асинхронный код встанет в очередь на выполнение, и останется только дождаться, когда он завершится, чтобы вызвать resolve или reject
* причём коллбэк resolve должен быть вызван в случае успешного выполнения асинхронной операции, а reject - если что-то пошло не так

### Состояние промиса ###

* как только объявляется промис, он попадает в состояние pending (выполняется)

		const myPromise = newPromise(() => {});

* затем, когда и если будут вызваны коллбэки resolve или reject, промис перейдёт в состояние settled (завершён)

		const myPromise = new Promise((resolve, reject) => {
			if (2 > 1) {
				resolve();
			} else {
				reject();
			}
		});

* состояние меняется автоматически в зависимости от вызываемого коллбэка, никакой специальный код, который будет явно менять состояние промиса, писать не нужно

* в зависимости от того, будет вызван коллбэк resolve или reject, состояние завершённости соответственно может быть fulfilled (завершён успешно) или rejected (завершён с ошибкой)

### Важно помнить о состояниях промиса ###

* промисы не позволяют откатиться на предыдущее состояние
* например, если был вызван resolve(), переводя тем самым промис в состояние fulfilled, то даже если сразу выполнить reject, состояние промиса не изменится:

		const myPromise = new Promise((resolve, reject) => {
			resolve(); // На этой строчке myPromise будет успешно завершён 
			reject(); // И вызов reject уже ни на что не повлияет
		});

* справедливо и обратное: после выполнения reject вызов resolve не приведёт к изменению состояния промиса


* видео про промисы
https://www.youtube.com/watch?v=1idOY3C1gYU&ab_channel=%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BB%D0%B5%D0%BD%D0%9C%D0%B8%D0%BD%D0%B8%D0%BD