# 9.20. Тестирование middleware для Redux

- у нас есть middleware redirect, который нужно покрыть тестами
- функция простая, но с точки зрения тестирования здесь есть несколько подводных камней

- наш middleware завязан на объект browserHistory, который мы подготовили самостоятельно, по факту это создание экземпляра BrowserHistory с помощью функции createBrowserHistory()
- этот объект мы подсовываем роутеру и получаем возможность управлять маршрутизацией не только из слоя React
- мы разработали redirect чтобы перенаправлять пользователя на страницу 404, если ресурс не найден

- первая проблема кроется в browserHistory
- у нас middleware напрямую импортирует browserHistory, и это - проблема
- эта проблема связана с тем, что browserHistory завязан на историю управления браузером, и он под node.js жить не может
- во-вторых, таких ситуация бывает много, когда у нас какой-то модуль импортирует какой-то пакет, который не может жить под node.js (а все наши тесты выполняются не в браузере, а под платформой node.js), поэтому, если там что-то не заработает, наш тест не сможет пройти

- вторая проблема: нам нужно понять, что происходит на этапе, когда мы делаем dispatch, меняется ли что-то по отношению к browserHistory

- чтобы это проверить, нужно придумать, что делать с browserHistory
- помимо browserHistory надо что-то сделать со store

- создадим модуль redirect.test.ts
- нам придётся замокать объект browserHistory для тестирования
- тестировать готовые пакеты мы не должны (потому что это должны делать их разработчики)

```ts
describe('Redirect middleware', () => {
  // проверим, что когда мы выполняем dispatch of redirectToRoute, то пользователь должен быть перенаправлен на страницу login
  // чтобы это проверить, мы должны понять, изменилось ли состояние объекта browserHistory
  it('should redirect to "/login" with redirectToRoute action', () => {

  });
});
```

- vitest предлагает функциональность для создания заглушек
- `vi.mock()` позволяет создать заглушку
- одним из вариантов заглушки может быть заглушка для целого модуля
- мы можем сказать, что, когда у нас будет происходить обращение к какому-то модулю, нужно не использовать тот оригинальный модуль, а использовать то, что мы захотим использовать
- например, мы можем сказать, что, когда у нас происходит обращение к значению default и получает browserHistory, мы можем сделать так, чтобы вместо оригинального модуля выполнялась наша функция и возвращала какой-то объект
- таким образом мы замокаем модуль browserHistory, и, когда любой код мы будем проверять, на самом деле будет использоваться наша заготовка

```ts
// первым аргументом передаём модуль, который мы хотим замокать
// вторым - функцию, которая должна возвращать то, что мы будем использовать вместо этого модуля (имитируем модуль)
// поскольку модуль использует ключевое слово default при экспорте, функция должна возвращать объект по дефолту
vi.mock('../../browser-history', () => ({
  default: {
    // когда происходит перенаправление пользователя, у нас меняется свойство locationPathName, оно приобретает новый путь
    // чтобы изменить этот путь, мы вызываем метод push()
    location: { pathname: ''},
    push(path: string) {
      this.location.pathname = path;
    }
  }
}))
```

- так как в middleware у нас есть обращение к store, нам нужно имитировать хранилище
- для этого мы можем воспользоваться специализированным пакетом "@jedmao/redux-mock-store"
- мы должны подготовить имитированный store, который по факту будет содержать все методы хранилища, и мы сможем тем самым проверять, как у нас происходит взаимодействие с хранилищем
- настоящее хранилище при этом поднято не будет
