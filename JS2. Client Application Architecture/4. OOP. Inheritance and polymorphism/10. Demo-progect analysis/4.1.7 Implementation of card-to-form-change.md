# 4.1.7 Реализация смены карточки на форму

- кнопка `loadMoreButton` работает, и теперь мы должны повторить этот опыт для дальнейшего описания логики

- у нас есть разные представления для задач:

  - задача может находиться в режиме редактирования - должна отображаться форма, в которую мы вводим данные для создания новой задачи
  - задача может отображаться в режиме просмотра

- у задачи есть кнопка `edit`, и мы можем перейти в расширенный вид, то есть перейти к форме редактирования

- для этого есть отдельный компонент - `taskEditView`, и в нём уже вводить данные и выполнять какие-то дальнейшие манипуляции

- нам нужно написать логику для нажатия на кнопку `edit`, то есть чтобы мы переключались на форму редактирования, а в форме редактирования нам надо сделать обработчик отправки формы, по которой мы будем выполнять обратное действие

- то есть когда произойдёт событие отправки формы нужно заменить форму редактирования на форму отображения представления задачи

## практика

- для начала необходимо организовать передачу обработчиков в наши компоненты

- для этого надо передать в конструктор объект со всей необходимой информацией

- в `taskView` надо передавать не только обработчик, но и данные для самой задачи, потому что они выводятся и отображаются в самой карточке задачи

- поэтому мы расширяем объект, который у нас используется в качестве параметра в конструктор и добавляем здесь ещё одно свойство `onEditClick`

- сразу же мы заводим в класса приватное свойство `#editHandleClick` и именно в это свойство мы сохраним ссылку на обработчик

- у нас вполне себе должно быть действие, которое должно вызываться по умолчанию, в данном случае это опять будет отмена действия браузера по умолчанию

- внутри конструктора мы сохраняем в `this.#handleEditClick` ссылку на `onEditClick`

- поскольку клик по кнопке должен приводить к какому-то действию, мы должны подписаться на соответствующее событие

- в TaskView в свойстве element у нас ссылка на элемент самой карточки - DOM элемент, который содержит в себе другие дочерние DOM-элементы

- искать мы должны только внутри компонента, нельзя взаимодействовать со всем `document`

- исключения - глобальные события типа обработки нажатия клавиш

- итак, в конструкторе мы находим кнопку редактирования по селектору класса и подписываемся с помощью `addEventListener` на событие клик, указываем ссылку на обработчик, который будет использоваться

- далее описываем этот обработчик (он у нас приватный), используем стрелочную функцию, чтобы не бороться с контекстом

- внутри этой функции мы используем `e.preventDefault()` и вызываем метод `this.#handleEditClick()`

```js
class TaskView extends AbstractView {
  #task = null;
  #handleEditClick = null;

  constructor ({task, onEditClick}) {
    super();
    this.#task = task;
    this.#handleEditClick = onEditClick;

    this.element.querySelector('.card__btn--edit').addEventListener('click', this.#editClickHandler);
  }

  get template() {
    // ...
  }

  #editClickHandler = (e) => {
    e.preventDefault();
    this.#handleEditClick();
  }
}
```

### компонент TaskEditView

- по большому счёту в нём ровно то же самое

- объявляем свойство `#handleFormSubmit`

- расширяем конструктор - добавляем `onFormSubmit`, где как раз таки и будет передаваться ссылка на функцию с действием, которое будет выполняться при отправке формы

- внутри конструктора мы сохраняем ссылку на эту функцию в свойство `this.#handleFormSubmit`

- подписываемся на соответствующее событие нашей формы - находим элемент формы по селектору и вызываем у него `addEventListener`

```js
class TaskEditView extends AbstractView {
  #task = null;
  #handleFormSubmit = null;

  constructor({ task = BLANK_TASK, onFormSubmit }) {
    super();
    this.#task = task;
    this.#handleFormSubmit = onFormSubmit;

    this.element
      .querySelector('.form')
      .addEventListener('click', this.#formSubmitHandler);
  }

  get template() {
    // ...
  }

  #formSubmitHandler = (e) => {
    e.preventDefault();
    this.#handleFormSubmit();
  };
}
```

## где пишется сама логика

- в презентере начинается модификация метода `renderTask()`

- мы должны здесь добавить дополнительные обработчики и инициализировать компоненты

- изначально мы инициализировали только один - `TaskView`

- теперь нам нужно инициализировать и `TaskView`, и `TaskEditView`, только показывать мы их будем по очереди

- это один из способов, которым можно добиться смены отображения

- то есть фактически у нас всегда показывается один компонент, но экземпляры мы создаём с самого начала

### создание компонента

- сначала мы создаём экземпляр компонента `TaskView` - `taskComponent`

- и описываем свойство onEditClick, где внутри мы описываем функцию, в которой должна быть логика по замене карточки

- внутри функции `onEditClick()` мы будем вызывать функцию `replaceCardToForm()`

- это функция, которая у нас располагается прямо здесь (объявляем декларативно)

- внутри этой функции вызывается функция фреймворка `replace()`

- функция `replace()` первым аргументом принимает компонент, который нужно показать, а вторым - который нужно скрыть

- должна быть ещё обратная функция, которая делает замену наоборот - `replaceFormToCard()`

- в ТЗ есть пункт, согласно которому должна быть предусмотрена возможность закрытия формы редактирования по клавише `ESC`

- в коллбэке, который мы передаём в `onEditClick`, мы описываем ту самую логику - обращаемся к `document`, указываем `addEventListener` и подписываемся на событие `keydown`, и указываем обработчик `escKeyDownHandler`

- этот обработчик описан выше: проверяем, что была нажата клавиша `ESC`, отменяем действие по умолчанию и вызываем функцию `replaceFormToCard()`, затем удаляем обработчик

### инициализация компонента taskEditComponent

- так же передаём ему в конструктор объект со всеми необходимыми данными: данные по задаче и свойство `onFormSubmit`, значением которого должна быть функция (стрелочная), у этой функции мы должны описать обратную логику: вызываем `replaceFormToCard()` и отписываемся от события `keydown`

```js
class presenter {
  /// ...
  #renderTask(task) {
    // const taskComponent = new TaskView({ task });
    const escKeyDownHandler = (evt) => {
      if (evt.key === 'Escape') {
        evt.preventDefault();
        replaceFormToCard();
        document.removeEventListener('keydown', escKeyDownHandler);
      }
    };
    const taskComponent = new TaskView({
      task,
      onEditClick: () => {
        replaceCardToForm();
        document.addEventListener('keydown', escKeyDownHandler);
      },
    });
    const taskEditComponent = new TaskEditView({
      task,
      onFormSubmit: () => {
        replaceFormToCard();
        document.removeEventListener('keydown', escKeyDownHandler);
      },
    });

    function replaceCardToForm() {
      replace(taskEditComponent, taskComponent);
    }

    function replaceFormToCard() {
      replace(taskComponent, taskEditComponent);
    }

    render(taskComponent, this.#taskListComponent.element);
  }
}
```
