# Array.prototype.sort() #

* метод sort() на месте сортирует элементы массива и возвращает отсортированный массив
* сортировка не обязательно устойчива, порядок сортировки по умолчанию соответствует порядку кодовых точек Unicode

## Синтаксис ##
arr.sort([compareFunction])

## Параметры ##
* compareFunction - необязательный параметр, указывает функцию, определяющую порядок сортировки
* если он отсутствует, массив сортируется в соответствии со значениями кодовых точек каждого символа Unicode, полученных путём преобразования каждого элемента в строку

## Возвращаемое значение ##
* метод возвращает отсортированный массив, копия массива не создаётся - массив сортируется на месте

## Описание ##
* если функция сравнения compareFunction не предоставляется, элементы сортируются путём преобразования их в строки и сравнения строк в порядке следования кодовых точек Unicode
* например, слово "Вишня" идёт перед словом "бананы"
* при числовой сортировке, 9 идёт перед 80, но поскольку числа преобразуются в строки, то "80" идёт перед "9" в соответствии с порядком в Unicode

		const fruit = ["арбузы", "бананы", "Вишня"];
		fruit.sort(); // ['Вишня', 'арбузы', 'бананы']

		const scores = [1, 2, 10, 21];
		scores.sort(); // [1, 10, 2, 21]

		const things = ["слово", "Слово", "1 Слово", "2 Слова"];
		things.sort(); // ['1 Слово', '2 Слова', 'Слово', 'слово']
		// в Unicode числа находятся перед буквами в верхнем регистре,
		// а те, в свою очередь, перед буквами в нижнем регистре

* если функция сравнения compareFunction предоставлена, элементы массива сортируются в соответствии с её возвращаемым значением
* если сравниваются два элемента a и b, то:

	-	если compareFunction(a, b) меньше 0, сортировка поставит a по меньшему индексу, чем b, то есть, a идёт первым
	-	если compareFunction(a, b) вернёт 0, сортировка оставит a и b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам. Обратите внимание: стандарт ECMAscript не гарантирует данное поведение, и ему следуют не все браузеры (например, версии Mozilla по крайней мере, до 2003 года)
	-	если compareFunction(a, b) больше 0, сортировка поставит b по меньшему индексу, чем a
	-	функция compareFunction(a, b) должна всегда возвращать одинаковое значение для определённой пары элементов a и b. Если будут возвращаться непоследовательные результаты, порядок сортировки будет не определён.
Итак, функция сравнения имеет следующую форму:

		function compare(a, b) {
			if (a меньше b по некоторому критерию сортировки) {
				return -1;
			}
			if (a больше b по некоторому критерию сортировки) {
				return 1;
			}
			// a должно быть равным b
			return 0;
		}

* для числового сравнения, вместо строкового, функция сравнения может просто вычитать b из a
* следующая функция будет сортировать массив по возрастанию:

		function compareNumbers(a, b) {
			return a - b;
		}

* метод sort можно удобно использовать с функциональными выражениями (и замыканиями):

		const numbers = [4, 2, 5, 1, 3];
		numbers.sort(function (a, b) {
			return a - b;
		});
		console.log(numbers); // [1, 2, 3, 4, 5]

* объекты могут быть отсортированы по значению одного из своих свойств

		const items = [
			{ name: "Edward", value: 21 },
			{ name: "Sharpe", value: 37 },
			{ name: "And", value: 45 },
			{ name: "The", value: -12 },
			{ name: "Magnetic" },
			{ name: "Zeros", value: 37 },
		];
		items.sort(function (a, b) {
			if (a.name > b.name) {
				return 1;
			}
			if (a.name < b.name) {
				return -1;
			}
			// a должно быть равным b
			return 0;
		});


## Примеры ##
* пример: создание, отображение и сортировка массива
* в следующем примере создаётся четыре массива, сначала отображается первоначальный массив, а затем они сортируются
* числовые массивы сортируются сначала без, а потом с функцией сравнения

		const stringArray = ["Голубая", "Горбатая", "Белуга"];
		const numericStringArray = ["80", "9", "700"];
		const numberArray = [40, 1, 5, 200];
		const mixedNumericArray = ["80", "9", "700", 40, 1, 5, 200];

		function compareNumbers(a, b) {
			return a - b;
		}

		// снова предполагаем, что функция печати определена
		console.log("stringArray:", stringArray.join());
		console.log("Сортировка:", stringArray.sort());

		console.log("numberArray:", numberArray.join());
		console.log("Сортировка без функции сравнения:", numberArray.sort());
		console.log(
			"Сортировка с функцией compareNumbers:",
			numberArray.sort(compareNumbers),
		);

		console.log("numericStringArray:", numericStringArray.join());
		console.log("Сортировка без функции сравнения:", numericStringArray.sort());
		console.log(
			"Сортировка с функцией compareNumbers:",
			numericStringArray.sort(compareNumbers),
		);

		console.log("mixedNumericArray:", mixedNumericArray.join());
		console.log("Сортировка без функции сравнения:", mixedNumericArray.sort());
		console.log(
			"Сортировка с функцией compareNumbers:",
			mixedNumericArray.sort(compareNumbers),
		);

* этот пример произведёт следующий вывод: когда используется функция сравнения, числа сортируются корректно вне зависимости от того, являются ли они собственно числами или строками с числами

		stringArray: Голубая,Горбатая,Белуга
		Сортировка: Белуга,Голубая,Горбатая

		numberArray: 40,1,5,200
		Сортировка без функции сравнения: 1,200,40,5
		Сортировка с функцией compareNumbers: 1,5,40,200

		numericStringArray: 80,9,700
		Сортировка без функции сравнения: 700,80,9
		Сортировка с функцией compareNumbers: 9,80,700

		mixedNumericArray: 80,9,700,40,1,5,200
		Сортировка без функции сравнения: 1,200,40,5,700,80,9
		Сортировка с функцией compareNumbers: 1,5,9,40,80,200,700


### пример: сортировка не-ASCII символов
* для сортировки строк с не-ASCII символами, то есть строк с символами акцента (e, é, è, a, ä и т.д.), строк, с языками, отличными от английского: используйте String.localeCompare. Эта функция может сравнивать эти символы, чтобы они становились в правильном порядке.

		var items = ["réservé", "premier", "cliché", "communiqué", "café", "adieu"];
		items.sort(function (a, b) {
			return a.localeCompare(b);
		});

		// items равен ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']

### пример: сортировка c помощью map
* функция сравнения (compareFunction) может вызываться несколько раз для каждого элемента в массиве
* в зависимости от природы функции сравнения, это может привести к высоким расходам ресурсов
* чем более сложна функция сравнения и чем больше элементов требуется отсортировать, тем разумнее использовать map для сортировки
* идея состоит в том, чтобы обойти массив один раз, чтобы извлечь фактические значения, используемые для сортировки, во временный массив, отсортировать временный массив, а затем обойти временный массив для получения правильного порядка.

		// массив для сортировки
		var list = ["Дельта", "альфа", "ЧАРЛИ", "браво"];

		// временный массив содержит объекты с позицией и значением сортировки
		var mapped = list.map(function (el, i) {
			return { index: i, value: el.toLowerCase() };
		});

		// сортируем массив, содержащий уменьшенные значения
		mapped.sort(function (a, b) {
			if (a.value > b.value) {
				return 1;
			}
			if (a.value < b.value) {
				return -1;
			}
			return 0;
		});

		// контейнер для результата
		var result = mapped.map(function (el) {
			return list[el.index];
		});