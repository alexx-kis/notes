# 9.23. Введение в React Testing Library

- при тестировании компонентов мы также будем писать юнит-тесты, где-то это будут интеграционные тесты, потому что мы будем проверять за один тест несколько моделей поведения этого компонента, и нам потребуются дополнительные инструменты
- таким инструментом в дополнение к Vitest станет Testing Library
- Testing Library - это отдельная библиотека, которая позволяет тестировать визуальную часть интерфейса при применении различных фреймворков и библиотек наподобие React
- Testing Library существует в виде отдельных имплементаций для react, react native, svelte итд - это универсальная библиотека, мы будем смотреть на неё с позиции React Testing Library, которая разрабатывалась с одним очень важным принципом - ориентация на пользователя и его поведение
- компоненты можно проверять разными способами
- например, если у компонента есть состояние, мы можем проверять, правильно ли компонент отрисовывается путём изменения его состояния
- то есть мы можем вторгнуться в личное пространство компонента, как-то поменять состояние, и посмотреть, правильно ли компонент отображается
- этот подход в контексте React применялся довольно часто, есть отдельный инструмент enzym, который позволяет проверять поведение компонентов, его особенность в том, что он позволяет вторгаться во внутренности компонента и тем самым нарушает принцип инкапсуляции
- чтобы убедиться, что компонент действительно работает правильно, этого делать не нужно
- в качестве альтернативного решения появилась Testing Library
- принципы для проверки корректности работы интерфейса (компонентов)

  - если компонент отображается правильно, если пользователь может получить то, что мы подразумеваем при создании компонента, значит компонент действительно работает правильно
  - мы не должны завязываться на разметку, которую формируют компоненты, потому что пользователи не работают с разметкой, пользователи работают с интерфейсом, который получается в результате рендера компонента

- например, на странице есть заголовок и кнопка "начать" [какое-то действие]
- чтобы убедиться, что компонент страницы работает правильно, мы должны понять, какую важную информацию компонент предоставляет, ради чего мы его создавали
- мы можем написать тест: мы должны убедиться, что после рендера компонента, появляется надпись и есть кнопка с определённым поведением
- для этого нам не нужно завязываться на разметку, мы можем оперировать теми же подходами, которыми пользуется пользователь
- таким образом мы сможем довольно просто тестировать компоненты и убеждаться, что они действительно работают

- React Testing Library предоставляет для этого всё, что необходимо:
  1. саму методологию, что мы ориентируемся на пользовательский опыт и проверяем, как компоненты взаимодействуют друг с другом, как они отображаются в интерфейсе
  2. простой API, чтобы мы могли проверить, есть ли соответствующий элемент на странице
  3. другие необходимые функции, которые упрощают написание тестов

Нюансы:

- компоненты бывают разные, есть максимально простые компоненты, типа Loader
- такой компонент проверить просто
- фактически нужно отрендерить этот компонент и, попробовать найти текст, который получился в результате
- есть более сложные компоненты, которые подключены к хранилищу
- чтобы протестировать такие компоненты, нужно подготовиться и решить несколько организационных моментов - замена зависимостей, чтобы мы могли что-то дальше делать

- начнём с простого - посмотрим, какие зависимости нужны для работы React Testing Library

- у Testing Library есть сайт testing-library.com

## Тестирование простых компонентов

- перед тем, как начать использовать React Testing Library, необходимо установить все зависимости в devDependencies:

  - `@testing-library/react`
  - `@testing-library/user-event` - модуль, который предоставляет библиотеку для имитации событий, возникающих при работе с пользователем, это позволит тестировать компоненты типа полей ввода
  - `@testing-library/jest-dom` - чтобы запускать тесты в окружении node.js
  - `@types/testing-library__jest-dom` - типы
  - `jsdom` - чтобы имитировать и проверять, как отрисовываются компоненты, с ними взаимодействовать, как это мы бы делали в DOM

- протестируем компонент LoadingScreen

```tsx
function LoadingScreen(): JSX.Element {
  return <p>Loading ...</p>;
}

export default LoadingScreen;
```

- как убедиться, что компонент отрисовывается корректно, - если мы видим текст "loading", неважно, в каком html-тэге, значит, всё работает корректно, и компонент готов к использованию
- если текст не появляется, значит компонент обновился, и надо обновить тест

- создадим файл с расширением .tsx (потому что они будут содержать код в JSX) для теста компонента в директории компонента `loading-screen.test.tsx`

- начнём так же с блока describe и описываем группу тестов

```tsx
import { render, screen } from '@testing-library/react';
import LoadingScreen from './loading-screen';s
// лучше указать слово Component, чтобы отличать тесты компонентов от других
describe('Component: Loading screen', () => {
  // тест должен проверить, что компонент отрисовывается корректно
  it('should render correct', () => {
    // как убедиться, что компонент рендерится корректно?
    // для этого нам надо сделать проверку, что мы увидим текст "loading"
    // используем здесь регулярное выражение
    // i - модификатор независимости регистра
    const expectedText = /Loading/i;

    // теперь как-то нужно отрендерить компонент
    // как отрендерить компонент, если мы запускаем тест в node.js, где нет DOM?
    // здесь поможет React Testing Library, которая предоставляет специальную функцию render(), которая позволяет отрисовать компонент с помощью React Testing Library
    // функция render() создаст виртуальное представление, и мы сможем манипулировать компонентом
    // аргументом передаём компонент, который хотим отрисовать
    render(<LoadingScreen />);

    // воспользуемся объектом screen, методом getByText(), аргументом передаём текст, который хотим найти
    // чтобы проверить, что текст отрендерился, используем метод .toBeInTheDocument()
    expect(screen.getByText(expectedText)).toBeInTheDocument();
  });
});
```

- протестируем компонент Mistakes

```tsx
// здесь появится первая сложность: здесь компонент принимает props и здесь нет текста, а только иконки
// Testing Library в таком случае рекомендует использовать data-атрибуты, то есть добавлять data-атрибуты, которые чётко позволяют идентифицировать элемент
// такой атрибут называется data-testid

type MistakesProps = {
  count: number;
};

function Mistakes({ count }: MistakesProps): JSX.Element {
  const mistakes = Array.from({ length: count }, () => '');

  return (
    <div
      className='game__mistakes'
      data-testid='mistake-container' // добавим атрибут
    >
      {mistakes.map((_item, index) => {
        const keyValue = `mistake-${index}`;
        return (
          <div
            key={keyValue}
            className='wrong'
            data-testid='mistake-value'// добавим атрибут
          />
        );
      })}
    </div>
  );
}

export default Mistakes;
```

```tsx
describe('Component: Mistakes', () => {
  it('should render correct', () => {
    // объявим переменную с ожидаемым количеством элементов-ошибок
    const expectedCount = 3;

    // зафиксируем id
    const mistakeContainerTestId = 'mistake-container';
    const mistakeValueTestId = 'mistake-value';

    // отрендерим компонент Mistakes, передадим в качестве props expectedCount
    render(<Mistakes count={expectedCount} />);

    // теперь мы должны найти соответствующие элементы
    // воспользуемся методом getByTestId объекта screen
    const mistakesContainer = screen.getByTestId(mistakeContainerTestId);
    const mistakeValues = screen.getAllByTestId(mistakeValueTestId); // тут будет коллекция элементов

    // выполняем проверку на наличие в документе
    expect(mistakesContainer).toBeInTheDocument();

    // проверяем, что количество элементов соответствует expectedCount
    expect(mistakeValues.length).toBe(expectedCount);
  });
});
```
