# Добавление логики показа дополнительных задач с кнопкой "Load More"

- В этой части проекта нужно реализовать кнопку "Load More", которая будет добавлять дополнительные задачи по мере нажатия
- Чтобы эта функциональность соответствовала паттерну MVP, потребуется разделить логику между презентером и компонентом LoadMoreButtonView

1. Увеличение отображаемых задач

   - Для добавления функциональности кнопки "Load More" нужно определить количество задач, которые отображаются изначально, и тех, которые добавляются при нажатии. В компоненте LoadMoreButtonView создаётся обработчик нажатия.

2. Где описывать обработчики?

- Обработчики событий должны быть организованы так, чтобы код был чистым и поддерживаемым
- В паттерне MVP обработчики логики располагаются в презентере, а вью-компоненты отвечают за визуальное представление и события
- События (например, нажатие кнопки) передаются через конструктор компонента, что позволяет контролировать действия снаружи и минимизировать зависимости между компонентами

## Передача данных и обработчиков в компонент

1. Публичные свойства — один из способов передачи данных и обработчиков. Однако такой подход не всегда удобен, так как разные компоненты могут требовать разных свойств, что усложняет работу с ними

2. Конструкторы с объектами — предпочтительный способ, где данные и обработчики передаются через объекты. Это даёт гибкость при передаче множества аргументов.

## Создание компонента LoadMoreButtonView

- Для реализации кнопки нужно создать компонент, в котором будет передаваться callback-обработчик через конструктор
- Этот обработчик будет сохраняться в приватном свойстве и вызываться при нажатии на кнопку
- В примере ниже показана структура компонента с приватным полем #handleClick, которое хранит callback.

```js
class LoadMoreButtonView extends AbstractView {
  #handleClick = null;

  constructor({ onClick }) {
    super();
    this.#handleClick = onClick;
    this.element.addEventListener('click', this.#clickHandler);
  }

  get template() {
    return createLoadMoreButtonTemplate();
  }

  #clickHandler = (e) => {
    e.preventDefault();
    this.#handleClick();
  };
}
```

## Реализация кнопки "Load More" в презентере

- Презентер будет содержать логику показа задач и обработку нажатия на кнопку
- Для этого потребуется зафиксировать количество задач, которые будут отображаться при первой загрузке и при каждом следующем нажатии
- Это количество можно хранить в константе TASK_COUNT_PER_STEP

- В презентере будет приватное свойство для отслеживания количества отображаемых задач — #renderedTaskCount, и если задач больше чем это значение, то необходимо показывать кнопку "Load More"

1. Первичная отрисовка задач

- В методе init() презентера нужно отобразить определённое количество задач
- Для этого применим Math.min, чтобы отобразить либо все задачи, либо ограниченное количество

```js
init() {
  //...
  for (let i = 0; i < Math.min(this.#boardTasks.length, TASK_COUNT_PER_STEP); i++) {
    this.#renderTask(this.#boardTasks[i]);
  }
}
```

2. Отрисовка кнопки "Load More"

- После отображения первой порции задач нужно проверить, есть ли ещё задачи для отображения
- Если да, то создаётся экземпляр кнопки и добавляется в DOM
- Обработчик для кнопки передаётся через конструктор как callback-функция #handleLoadMoreButtonClick

```js
if (this.#boardTasks.length > TASK_COUNT_PER_STEP) {
  this.#loadMoreButtonComponent = new LoadMoreButtonView({
    onClick: this.#handleLoadMoreButtonClick,
  });
  render(this.#loadMoreButtonComponent, this.#boardComponent.element);
}
```

3. Логика нажатия на кнопку

- Когда пользователь нажимает на кнопку, презентер должен показать следующие задачи
- В методе #handleLoadMoreButtonClick происходит отрисовка следующей порции задач, после чего обновляется счётчик #renderedTaskCount
- Если задач больше не осталось, кнопку "Load More" нужно удалить

```js
#handleLoadMoreButtonClick = () => {
  this.#boardTasks
    .slice(this.#renderedTaskCount, this.#renderedTaskCount + TASK_COUNT_PER_STEP)
    .forEach((task) => this.#renderTask(task));

  this.#renderedTaskCount += TASK_COUNT_PER_STEP;

  if (this.#renderedTaskCount >= this.#boardTasks.length) {
    remove(this.#loadMoreButtonComponent);
  }
}
```

## Важные моменты:

- Подписка на события через addEventListener в компоненте: В методе addEventListener не нужно искать кнопку по всему документу, так как её можно получить через this.element

- Использование стрелочных функций: Для сохранения контекста объекта внутри обработчиков событий применяется синтаксис стрелочных функций
- Это позволяет избежать потери контекста (this) при вызове методов объекта

Такой подход делает компонент кнопки универсальным и удобным для использования в разных частях приложения.
