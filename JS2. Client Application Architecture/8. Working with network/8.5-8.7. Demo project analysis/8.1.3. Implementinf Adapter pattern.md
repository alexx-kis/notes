# Реализация паттерна Адаптер

- не всегда данные с сервера приходят в том виде, в котором мы ожидаем
- многие преобразования можно делать прямо на клиенте, то есть в нашем приложении
- для этого используется специальный паттерн Адаптер, который позволяет объектам с несовместимыми интерфейсами работать вместе

- в классе `TaskApiService` сделаем новый метод, который будет называться `adaptToServer`
- он будет адаптировать данные, которые мы будем отправлять на сервер
- сервер ожидает данные в `snake_case`
- метод на вход принимает объект задачи и преобразует этот объект к виду, который ожидает сервер

- внутри метода заводим переменную `adaptedTask`, это будет объект
- изначально копируем в этот объект всё их исходной задачи, а потом преобразуем отдельные поля
- для дат нужно выполнить преобразование к строке
- сервер ожидает дату в формате `ISOString`
- выполняем проверку, что если у нас в задаче поле содержит экземпляр объекта `Date`, значит дата задана и их неё можно получить обычную строку
- чтобы получить дату в формате `ISOString`, вызываем метод `toISOString()`
- то же самое делаем с флагами

- теперь, так как мы выполнили преобразование, нам не нужны лишние ключи, удаляем их оператором `delete`

- на выходе у нас получается объект задачи в том виде, в котором его от нас ожидает сервер

```js
  #adaptToServer(task) {
    const adaptedTask = {...task,
      'due_date': task.dueDate instanceof Date ? task.dueDate.toISOString() : null, // На сервере дата хранится в ISO формате
      'is_archived': task.isArchive,
      'is_favorite': task.isFavorite,
      'repeating_days': task.repeating,
    };

    // Ненужные ключи мы удаляем
    delete adaptedTask.dueDate;
    delete adaptedTask.isArchive;
    delete adaptedTask.isFavorite;
    delete adaptedTask.repeating;

    return adaptedTask;
  }
```

- теперь в методе `updateTask()` воспользуемся методом `#adaptToServer`
- то есть когда мы описываем тело запроса, не просто передаём объект задачи, а пропускаем его через `adaptToServer()`

```js
  async updateTask(task) {
    const response = await this._load({
      //...
      body: JSON.stringify(this.#adaptToServer(task)),
      //...
    });

    //...
  }
```

- а в модели мы делаем обратный метод `adaptToClient()`, в котором выполняем обратное преобразование:
- получаем от сервера объект с описанием задачи, создаём переменную, в которую присваиваем объект
- сначала всё копируем из объекта, который пришёл с сервера, а затем выполняем преобразование, определяем ключи и записываем в них значения
- для даты нужно создать экземпляр объекта `Date()`, в который передать строку в формате ISO
- лишние флаги удаляем
- возвращаем адаптированный объект задачи

```js
  #adaptToClient(task) {
    const adaptedTask = {...task,
      dueDate: task['due_date'] !== null ? new Date(task['due_date']) : task['due_date'], // На клиенте дата хранится как экземпляр Date
      isArchive: task['is_archived'],
      isFavorite: task['is_favorite'],
      repeating: task['repeating_days'],
    };

    // Ненужные ключи мы удаляем
    delete adaptedTask['due_date'];
    delete adaptedTask['is_archived'];
    delete adaptedTask['is_favorite'];
    delete adaptedTask['repeating_days'];

    return adaptedTask;
  }
```


- почему `adaptToClient()` находится в модели, а не в сервисе? да он может находиться вообще в отдельном классе, в котором реализуется паттерн Адаптер, и потом этот класс импортировать туда, где нужно выполнять преобразования

### как пользоваться методом `adaptToClient()`

- пока в конструкторе при выводе задач в консоль
- итерируемся по массиву объектов-задач методом `map()`, чтобы выполнить преобразование, и для каждого объекта, который есть в этом массиве вызываем метод `adaptToClient()`
- в итоге у нас получится массив объектов-задач со структурой, которая используется в нашем приложении

- теперь в принципе можно отказаться от моковых данных