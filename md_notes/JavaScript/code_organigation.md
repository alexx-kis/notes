# Организация кода

## Введение в ECMAScript-модули

- Модуль - это функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом

- Законченный фрагмент кода - это фрагмент, который выполняет конкретно поставленную задачу

- Преимущества модульного подхода
  - каждая команда фокусируется на своей задаче
  - некоторые команды могут делать свою работу параллельно и независимо друг от друга
  - команду или результат её работы можно легко заменить

-Из преимуществ вытекает правило - модули должны быть максимально универсальными

-Задачи модуля

- Пространство имён

- Модуль изолирует пространство имён, чтобы переменные из одного модуля не попадали в другой модуль, как это бывает с глобальными переменными - всё, что создаётся в модуле, остаётся в модуле

          // Файл mother.js
          const name = 'Eve';

          // Файл father.js
          const name = 'Adam';

- в каждом из модулей есть переменная name, и ни одна из них не попадёт в глобальную область видимости window - если подключить оба файла к странице, конфликтов не будет

### Зависимости

- модуль должен описывать и давать понимание, какие у него есть зависимости, например, модуль может зависеть от других модулей:

        // Файл сain.js
        import {name} from './mother.js';

        `My mother is ${name}`; // My mother is Eve

- модуль cain.js зависит от модуля mother.js, а конкретно от переменной name, полученной из этого модуля

### Интерфейс

- модуль должен описывать интерфейс - методы и свойства - которые он может предоставить другим модулям
- чтобы предыдущий пример работал, нужно показать, что у модуля mother.js в интерфейсе есть свойство name, которое могут использовать другие модули

        // Файл mother.js
        const name = 'Eve';

        export {name};

- чтобы браузер считал JS-файл модулем, его нужно подключить как модуль:

        <script type="module" src="сain.js"></script>

- модули по умолчанию работают в строгом режиме, поэтому нет необходимости писать 'use strict'

## Экспорт и импорт

### Просто импорт

- когда нужно только выполнить код модуля, достаточно просто его импортировать

        // Файл alert.js
        alert('Hello, world!');

        // Файл index.js
        import './alert.js';

### Именованные экспорт и импорт

- в одном модуле нужно явно написать, что экспортировать:

        // Файл mother.js
        const name = 'Eve';
        const age = 18;

        export const sex = 'female'; // Экспорт сразу при объявлении

        export {name, age}; // Экспорт уже объявленных переменных

- а в другом нужно написать, что импортировать:

        // Файл сain.js
        import {name} from './mother.js';

        `My mother is ${name}`; // My mother is Eve

## Нюансы

### код модуля выполняется целиком:

- независимо от того, импортирован ли просто модуль или какие-то конкретные переменные из модуля, браузер выполнит код всего модуля

### только первый уровень:

- import и export не могут быть вложены в функции или другие блоки кода

### никакого поднятия:

    •	импортированные переменные не поднимаются, поэтому import всегда должен быть в начале файла

- переменные, объявленные через let могут изменяться внутри модуля (как и обычно), но после импорта в другой модуль их уже нельзя изменять, они становятся readonly, поэтому лучше экспортировать const-переменные

- однако можно изменить let-переменную в исходном модуле, при этом она поменяется в местах импорта

- поэтому всегда лучше экспортировать только const-переменные

- если передаётся объект (объектный тип данных), то после импорта можно поменять значения его свойств
- чтобы снизить риск ошибки, нужно экспортировать значения в конце модуля и не использовать экспорт "по месту"

- лучше вообще экспортировать только функции

- даже, например, функции, которые создают/возвращают объекты

## Пути импорта

- путь может быть указан в одинарных или двойных кавычках:

        import mother from './mother.js';
        import mother from "./mother.js";

- путь может быть абсолютным или относительным:

        import 'https://jakearchibald.com/utils/bar.js'; // URL
        import '/utils/bar.js'; // Абсолютный путь относительно домена
        import './bar.js'; // Относительный путь от текущего модуля
        import '../bar.js'; // Относительный путь от родительской директории

- если при загрузке модуля или его дочерних модулей (тех, которые он импортирует) произошла ошибка, все родительские модули (которые его импортируют) не будут загружены
- путь в конструкции import является константой и не может быть сборным

        import 'https://funny-random-script.zone/' + Math.random() + '/script.js'; // Так нельзя
        import `https://funny-random-script.zone/${Math.random()}/script.js`; // И так нельзя
        import 'https://funny-random-script.zone/' + 'js/' + 'script.js'; // Так тоже нельзя

        const path = 'https://funny-random-script.zone/js/script.js';
        import path; // Даже так нельзя

## Как использовать модули

- модулем может быть:
  - узко специализированный код, который решает ровно одну задачу (например, валидация формы или работа всплывающего окна)
  - несколько функций, записанных в объект (например, объект Math) - такой объект часто называют пространством имён (namespace)
  - библиотека - полезный набор инструментов, который может переноситься из проекта в проект

## Как делить код на модули

- разделить файлы логически - по тому, что они делают
- найти повторяющийся код внутри модулей и вынести в отдельный модуль (принцип DRY)

- на страницу подключается только точка входа - один js файл - main.js, а уже в него подключаются другие модули

- в точке входа должно быть минимум каких-либо логических операций

- в файле util.js нужно хранить вспомогательные функции, например, которые генерируют случайное число или возвращаются случайный элемент массива

## Переименованный экспорт

- бывают случаи, когда в одном модуле экспортируется переменная, которая уже существует в другом - то есть есть две переменные с одинаковым названием в двух разных модулях

        // Файл сain.js
        import {name} from './mother.js';
        import {name} from './father.js';

        const name = 'Сain';

#### Три переменных "name"?

- можно изменить название в экспортирующем модуле, но это не гибкое решение, и, если модуль чужой, в этом модуле ничего поменять не получится

#### решение

- импортируемые переменные можно переименовывать:

        // Файл сain.js
        import {name as motherName} from './mother.js';
        import {name as fatherName} from './father.js';

        const name = 'Сain';

        `My mother is ${motherName}`; // My mother is Eve
        `My father is ${fatherName}`; // My father is Adam
        `My name is ${name}`; // My name is Сain

- таким же образом можно переименовать переменную при экспорте, но это редко:

        // Файл mother.js
        const name = 'Eve';

        export {name as motherName};

        // Файл сain.js
        import {motherName} from './mother.js';

### Импортировать как...

- когда у модуля только именованный экспорт, перечислять все переменные долго
- для этого можно воспользоваться конструкцией import \* - и импортировать все именованные экспорты в одно пространство имён:

        // Файл mother.js
        const name = 'Eve';
        const age = 18;

        export const sex = 'female';

        export {name, age};

        // Файл сain.js
        import * as mother from './mother.js';

        mother; // {sex: 'female', name: 'Eve', age: 18}
