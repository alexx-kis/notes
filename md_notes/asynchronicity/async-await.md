# Async/Await #

* промисы упрощают написание асинхронного кода, строить цепочки вместо «ада коллбэков» удобнее, а поддерживать такой код проще
* но асинхронный код на промисах можно сделать ещё понятнее, в этом помогут операторы async и await

* в основе работы операторов async и await лежат промисы, просто эти операторы позволяют использовать промисы в другом синтаксисе
* их задача ещё больше упростить написание асинхронного кода и сделать его похожим (визуально!) на синхронный

## async ##

* оператор async позволяет определить асинхронную функцию
* результатом выполнения такой функции всегда будет новый промис
* async применяется при объявлении функций как декларативно, так и для функций-выражений:

      // Function Declaration
      async function foo () {}

      // Function Expression
      const bar = async function () {};

      // Arrow Function Expression
      const baz = async () => {};

      console.log(foo()); // Promise
      console.log(bar()); // Promise
      console.log(baz()); // Promise        
      
* если бы не ключевое слово async, то это были бы обычные синхронные функции

* попробуем немного усложнить пример и вернуть из асинхронной функции какое-нибудь значение, пусть им станет традиционная фраза Hello, world:

      async function foo () {
        return 'Hello, world';
      }

      foo()
        .then((text) => console.log(text)); // Hello, world


* асинхронная функция foo состоит из одного действия: возвращает строку Hello, world
* поскольку функция асинхронная, то результатом её выполнения будет промис (именно промис, а не строка Hello, world в чистом виде), и чтобы получить строку, нужно воспользоваться методом then()
* это лишний раз доказывает, что промисы никуда не делись, мы по-прежнему вызываем метод then, передаём ему функцию, которая будет вызвана при выполнении промиса, и так далее

* достичь аналогичного результата можно с помощью статического метода resolve у объекта Promise:

      const foo = () => Promise.resolve('Hello, world');

      foo()
        .then((text) => console.log(text));
        
      
* да, оператор async упрощает создание асинхронных функций, но нам по-прежнему нужно использовать цепочки, и нельзя сказать, что синтаксис стал проще или ближе к синхронному

## await ##

* оператор await позволяет дождаться выполнения промиса, за счёт чего достигается сходство с синхронным кодом
* иными словами оператор await вместе с оператором async образуют тандем, который как раз позволяет сделать асинхронный код похожим на синхронный

* важное уточнение, изначально await был доступен только в асинхронных функциях (async)
* спецификация ECMAScript 2022 расширила поведение, сделав возможным применение await на верхнем уровне, вне async функции
* поддержка есть во всех актуальных версиях браузеров и в Node.js (при использовании ES-модулей)

* рассмотрим предыдущий пример с Hello, world c использованием await вместо then:

      async function foo () {
        return 'Hello, world';
      }

      const text = await foo();
      console.log(text); // Hello, world        
      
## async и await на практике ##
* попробуем решить типичную асинхронную задачу: запросим от сервера список публикаций
* сервером выступит уже знакомый вам сайт «JSON Placeholder»

* как это бы выглядело на промисах:

      function getPosts (callback) {
        fetch('https://jsonplaceholder.typicode.com/posts')
          .then((response) => response.json())
          .then(callback);
      }

      getPosts((posts) => {
        console.log('Список публикаций:');
        console.log(posts);
      });


* как это выглядит с async и await:

      async function getPosts () {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        const posts = await response.json();

        return posts;
      }

      const posts = await getPosts();
      console.log('Список публикаций:');
      console.log(posts); // Выведет массив с данными


* асинхронная функция getPosts вызывает fetch для отправки запроса на получение списка публикаций
* затем извлекает и разбирает данные вызовом response.json()
* метод json() тоже возвращает промис, поэтому к нему тоже применяет оператор await
* после мы возвращаем из getPosts промис с готовыми данными, нам остаётся лишь их получить в нужном месте

* в строчках или количестве символов мы не выиграли, но с async и await асинхронный код стал похожим на синхронный, что снижает риск запутаться в коллбэках и цепочках

## Обработка ошибок ##

* при работе с промисами для обработки ошибок используется метод catch
* при использовании async и await обрабатывать ошибки можно с помощью конструкции try...catch:

      async function getPosts () {
        let response;

        try {
          // Специально укажем некорректный адрес /404
          response = await fetch('https://jsonplaceholder.typicode.com/404');
          if (!response.ok) {
            throw new Error(`${response.status} — ${response.statusText}`);
          }
        } catch (err) {
          // В случае ошибки вернём пустой массив публикаций,
          // но можно делать, что угодно
          return [];
        }

        const posts = await response.json();

        return posts;
      }

      const posts = await getPosts();
      console.log('Список публикаций:');
      console.log(posts); // []
        
        
      
* при выполнении метода fetch мы проверяем свойство ответа ok, и если запрос был выполнен с ошибкой, то бросаем исключение, которое будет перехвачено в блоке try...catch
* и в этом случае функция getPosts вернёт промис с пустым массивом в качестве данных