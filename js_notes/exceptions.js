//  Исключительные ситуации

// когда мы пишем программы, мы рассчитываем на то, что они будут работать корректно, однако могут возникать различные ситуации типа обрыва связи, данные могут приходить не в ожидаемом виде, при записи файлов может закончиться место на диске, файл может не существовать и другие

// такие ситуации приводят к невозможности или бессмысленности завершения запланированной операции

// бывают ситуации, когда происходит ошибка, не вызывающая сбой, например, пользователь вводит email в некорректном формате - программа не может обрабатывать email, но это не исключительная ситуация, так как программа сама может исправить ситуацию - вывести сообщение об ошибке, и пользователь повторит свой ввод


// Виды возникающих ситуаций

// в JS очень мало ситуаций, в которых возникают исключения, так как
// 1. очень мало мест для их возникновения
// 2. JS много когда не воспринимает ошибки, как ошибки типа деления на 0 или некорректный HTML код

// примеры
// некорректный JSON:
// const data = JSON.parse('{"1, 2, 3, 4, 5"}'); // код внутри не в двойных кавычках и не в виде ключ-значение
// такая ошибка приведёт к выводу в консоль соответствующего сообщения

// наша задача в том, чтобы отловить такие ситуации и как-то справиться с ними, не давая программе совсем прекратить своё выполнение
// для этого есть специальная конструкция try-catch


// Перехват исключений

// для перехвата исключений используется конструкция try-catch

// try {
// 	// код
// } catch(error) {
// 	// обработка ошибки
// }

// в блоке try следует размещать код, который может содержать исключение
// если при выполнении этого кода возникнет исключительная ситуация, то скрипт не выдаст ошибку в консоли, а начнёт выполнять код блока catch
// в блоке catch нужно каким-то образом отреагировать на ошибку, например, показать сообщение пользователю или через какое-то время повторить код (если это связано с соединением с интернетом)

// если при выполнении блока try никаких исключений не случилось, то полезный код просто выполнится, а код из блока catch проигнорируется

// try {
// 	const data = JSON.parse('{1, 2, 3, 4, 5}');
// } catch (error) {
// 	console.log('ошибка разбора JSON'); // выведется сообщение, так как JSON некорректен
// }
// Перехват исключений во вложенном коде
// особенность и удобство исключений в том, что их можно ловить при любом уровне вложенности кода
// например, есть функция, сохраняющая данные в локальное хранилище:

// const save = (str) => {
// 	localStorage.setItem('key', str);
// };

// при переполнении хранилища метод setItem выбросит исключение, но необязательно его ловить внутри функции save, можно обернуть в try каждый вызов самой функции:
// try {
// 	save('строка');
// } catch (error) {
// 	console.log('закончилось место в локальном хранилище');
// }

// Объект с ошибкой

// если возникает исключение, то в первый параметр блока catch попадёт объект со случившейся ошибкой
// свойство name этого объекта содержит имя ошибки (фактически её тип), а свойство message - текст этой ошибки

// try {

// } catch (error) {
// 	console.log(error.name);
// 	console.log(error.message);
// }

// пример

// try {
// 	const json = `{
// 		"key": "value",
// 		"key2": "value2", 
// 	}`; // в json запрещены запятые в конце
// 	const data = JSON.parse(json);
// 	console.log(data);
// } catch (error) {
// 	console.log(error.name);  	// SyntaxError
// 	console.log(error.message);  // Expected double-quoted property name in JSON at position 42
// }


// Основные типы исключений
// TypeError - ошибка, возникающая при недопустимом типе для переменой или параметра
// SyntaxError - ошибка, возникающая при разборе исходного кода или JSON
// RangeError - ошибка, возникающая при попытке передать параметром функции число, которое не входит в допустимый диапазон значений этого параметра функции (например, при создании массива с неправильной длиной через конструктор Array)

// Применение типов исключений
// пусть есть функция, параметром принимающая JSON с массивом данных и записывающая каждый элемент этого массива в локальное хранилище

// const saveData = (json) => {
// 	const arr = JSON.parse(json);

// 	for (let i = 0; i < arr.length; i++) {
// 		localStorage.setItem(i, arr[i]);
// 	}
// };


// в данной функции исключение может возникнуть в двух местах: при разборе JSON и при попытке сохранения данных в локальное хранилище
// пусть в качестве обработки ошибок выводится некоторое сообщение о проблемах

// try {
// 	saveData('{1, 2, 3, 4, 5}');
// } catch (error) {
// 	console.log('какие-то проблемы');
// }

// такое сообщение никак не дифференцирует возникшие проблемы, более логично было бы вывести сообщение о том, какая именно ошибка возникла:
// try {
// 	saveData('{1, 2, 3, 4, 5}');
// } catch (error) {
// 	if (error.name === 'QuotaExceededError') {
// 		console.log('закончилось место в хранилище');
// 	}
// 	if (error.name === 'SyntaxError') {
// 		console.log('некорректный JSON');
// 	}
// }

// Выбрасывание исключений
// могут быть такие ситуации, которые для JS не являются исключительными, но нужно показать ошибку
// для этого необходимо создать исключение с помощью new Error, параметром передав текст исключения:
// new Error('текст исключения');
// затем это исключение нужно "выбросить" с помощью команды throw:
// throw new Error('текст исключения');

// выбрасывание исключения заставляет JS думать, что случилась исключительная ситуация, это значит, что такое исключение можно отловить с помощью try-catch и обработать нужным образом
// например, есть функция, которая делит одно число на другое:
// const divide = (num1, num2) => {
// 	return num1 / num2;
// };

// пусть деление на 0 запрещено, при попытке сделать это должно возникать исключение
// для этого будем проверять в функции, нет ли попытки делить на 0, если нет - будем делить, если да - будем бросать исключение:

// const divide = (num1, num2) => {
// 	if (num2 !== 0) {
// 		return num1 / num2;
// 	}
// 	throw new Error('нельзя делить на 0');
// };
// console.log(divide(4, 2)); // 2
// console.log(divide(4, 0)); // Error: нельзя делить на 0

// в этом случае выполнение скрипта прервётся и в консоли появится ошибка
// чтобы скрипт не ломался, нужно перехватывать ошибку и как-то её обрабатывать
// try {
// 	console.log(divide(4, 0));
// } catch (error) {
// 	console.log(error.name);	// Error
// 	console.log(error.message); // нельзя делить на 0
// 	console.log('попытка деления на 0'); // попытка деления на 0
// }


// Выбрасывание различных типов исключений

// если выбросить своё исключение, то у него будет тип (name) - Error
// try {
// 	throw new Error('текст исключения');
// } catch (error) {
// 	console.log(error.name); // 'Error'
// 	console.log(error.message); // 'текст исключения'
// }

// такой же тип будет у любых исключений, выброшенных подобным образом
// это не всегда удобно, так как, если будет несколько исключений, то их нельзя будет отличить друг от друга
// в JS предусмотрено, что можно выбрасывать исключения не только типа Error, но и любого встроенного (TypeError, SyntaxError, RangeError)

// try {
// 	throw new SyntaxError('текст исключения');
// } catch (error) {
// 	console.log(error.name); 		//SyntaxError
// 	console.log(error.message);	// 'текст исключения'
// }


// Выбрасывание своих типов исключений

// количество встроенных в JS исключений не такое большое
// поэтому в JS есть возможность создавать исключения со своим типом
// самый простой способ сделать это - в throw передать объект с ключами name и message:
// try {
// 	throw { name: 'myError', message: 'текст исключения' };
// } catch (error) {
// 	console.log(error.name); 		// myError
// 	console.log(error.message);	// текст исключения
// }

// const getSquareRoot = (number) => {
// 	if (number >= 0) {
// 		return Math.sqrt(number);
// 	} else {
// 		throw { name: 'math error', message: 'нельзя извлекать корень из отрицательного числа' };
// 	}
// };

// try {
// 	console.log(getSquareRoot(16)); //4
// 	console.log(getSquareRoot(-16));
// } catch (error) {
// 	console.log(error.name);			// math error
// 	console.log(error.message);		// нельзя извлекать корень из отрицательного числа
// }


// Проброс исключений

// пусть есть блок catch, в котором ловятся два запланированных исключения:
// catch (error) {
// 	if (error.name == 'SyntaxError') {
// 		alert('Некорректный JSON продукта');
// 	} else if (error.name == 'ProductCostError') {
// 		alert('У продукта отсутствует цена или количество'); 
// 	}
// }

// в случае, если возникает непредусмотренное исключение другого типа, оно тоже попадёт в блок catch, но никакой реакции не будет (так как такое исключение не подходит не под одно из условий) - даже не будет ошибки в консоли, код просто перестанет работать

// поэтому есть правило: код должен ловить только те исключения, с которыми знает, как справиться, а если исключение неизвестное, то его нужно "пробросить" дальше с помощью throw - в этом случае выше его поймает кто-то более осведомлённый либо исключение отобразится ошибкой в консоли:

// catch (error) {
// 	if (error.name == 'SyntaxError') {
// 		alert('Некорректный JSON продукта');
// 	} else if (error.name == 'ProductCostError') {
// 		alert('У продукта отсутствует цена или количество'); 
// 	} else {
// 		throw error; // пробрасываем исключение далее
// 	}
// }