# 9.12 Тестирование бизнес логики

# 9.1 Добавление основы для теста

- установить пакет vitest (тестовый фреймворк), testing-library/react, testing-library/jest-dom, testing-library/user-event (эти зависимости уже установлены в проект в devDependencies)
- также нужен скрипт "test", который позволяет запускать тесты

```json
// package.json

  "scripts": {
    //...
    "test": "vitest --passWithNoTests"
  },
```

- начинать будем с простых юнит-тестов

- написание теста начинается с создания файла - typescript-модуля - рядом с тем модулем, который будем тестировать
- у файлов с тестами постфикс test, по этому постфиксу тестовый runner из фреймворка сможет определить тестовые модули и выполнить их запуск

- начнём тестировать модуль `game.ts`, в этом модуле собраны функции для проверки корректности ответа, то есть правильно ли пользователь выбрал ответ в игре

- у нас есть несколько функций; по факту это и есть бизнес-логика приложения
- создадим файл `game.test.ts`

- после установки vitest нам стали доступны дополнительные функции, которые нам нужны для оформления тестов

- одна из таких функций - `describe()` - она позволяет описать группу тестов
- например, есть группа тестов для проверки работоспособности функции isGenreAnswerCorrect
- таких тестов может быть несколько, потому что мы можем проверять, когда мы передаём правильный ответ, мы можем проверять обратную ситуацию, когда мы передаём функции заведомо неправильный ответ, и можем убедиться, что функция действительно скажет, что выбран неправильный ответ
- поэтому тестов для такой функции будет несколько
- чтобы не запутаться в этих тестах, их удобно объединять в группы

- функция describe() ожидает 2 аргумента:

  1. имя теста или группы тестов
  2. сам callback - функцию, в которой будет описан тестовый случай

- назовём группу 'Function: isArtistAnswerCorrect'

- дальше мы должны описать сам тестовый случай, их может быть несколько (позитивный - когда пользователь выбрал правильный ответ, и негативный - когда пользователь выбрал неправильный ответ)

- каждый тестовый случай описывается с помощью функции `it()` (есть ещё функция `test()`, которая делает то же самое)
- первым аргументом в функцию `it()` нужно передать название тестового случая, то есть, что мы ожидаем получить от этой проверки
- опишем первый тестовый случай 'should return "true" when answer is correct'
- вторым аргументом в эту функцию передаём callback, где мы опишем тестовый случай

```ts
describe('Function: isArtistAnswerCorrect', () => {
  it('should return "true" when answer is correct', () => {
    // Тестовый случай
  });
});
```

- все тесты строятся по одинаковому алгоритму, для этого даже был придуман соответствующий паттерн, он называется "ААА" (Arrange - Act - Assert)

- этот паттерн задаёт структуру теста, и она актуальна для любого теста

1. на этапе Arrange (подготовка) мы готовим состояние, необходимое для выполнения теста (объявляем переменные, готовим тестовые данные)

2. на этапе Act (действие) мы выполняем действие, которое собираемся проверить - здесь будет вызов функции isArtistAnswerCorrect

3. на этапе Assert (проверка) будет выполняться проверка результата

- здесь мы должны воспользоваться assertion library, и убедиться, что тест действительно проходит, что функция возвращает то значение, которое мы от неё ожидаем

# 9.2 Добавление описания тестового случая

- для тестирования функции isArtistAnswerCorrect, нам нужно подготовить какие-то данные
- это те данные, которые принимает сама функция isArtistAnswerCorrect аргументами
- то есть нам нужно подготовить какой-то вопрос, который соответствует типу QuestionArtist и нужно подготовить ответ, который соответствует типу UserArtistQuestionAnswer

- когда мы всё это подготовим, мы сможем вызвать функцию, передать ей эти значения и получить результат её выполнения

- а сколько раз нам придётся пользоваться этими данными и сколько раз нам их готовить?
- скорее всего неоднократно, поэтому не помешает функция, которая сможет постоянно эти данные подготавливать

- создадим директорию utils, а в ней файл mocks.ts
- в этом файле мы будем описывать функции, которые будут помогать выполнять тесты

- создадим первую функцию в файле mocks.ts `makeFakeArtistQuestion()`
- это функция, которая позволит нам подготовить тестовый (моковый) объект для игры "Угадай исполнителя"
- она должна вернуть объект, который соответствует структуре QuestionArtist и там будут какие-то случайные данные

- а почему нам не использовать данные, которые возвращает сервер? - такие тесты будет сложнее поддерживать

- функция makeFakeArtistQuestion будет генерировать данные
- она возвращает объект структуры QuestionArtist

- для создания тестовых значений воспользуемся пакетом Faker (он уже установлен в devDependencies), этот пакет позволяет получать случайные строки определённого вида

- например, пакет предоставляет несколько различных функций, которые позволяют получать тематические строки

- в качестве type укажем GameType.Artist
- в свойстве song задаём свойства artist и src
- чтобы не придумывать имена, используем объект name, и используем его метод title() - он вернёт имя и фамилию
- для пути используем объект system и его метод filePath(), с виду это будет валидный путь к файлу в системе
- в поле answers - массив ответов - генерируем массив из 3 элементов, и дальше генерируем объекты с ответами

```ts
// mocks.ts

import { system, name, internet } from 'faker';
import { GameType } from '../const';
import { QuestionArtist } from '../types/question';

export const makeFakeArtistQuestion = (): QuestionArtist =>
  ({
    type: GameType.Artist,
    song: {
      artist: name.title(),
      src: system.filePath(),
    },
    answers: new Array(3)
      .fill(null)
      .map(() => ({ picture: internet.avatar(), artist: name.title() })),
  } as QuestionArtist);
```

- в тестовом случае в разделе Arrange подготовим вопрос с помощью функции makeFakeArtistQuestion
```ts
const mockArtiestQuestion = makeFakeArtistQuestion();
```
- также нужно получить корректный ответ
```ts
const { artist: correctAnswer } = mockArtiestQuestion.song;
```

- в разделе Act нужно выполнить то самое действие, которое вызовет нашу функцию
- объявим переменную result и присвоим ей результат выполнения функции isArtistAnswerCorrect()
- аргументом передаём тестовый вопрос, а в качестве ответа передадим correctAnswer
```ts
const result = isArtistAnswerCorrect(mockArtiestQuestion, correctAnswer);
```

- теперь воспользуемся assertion library и сравним результат с ожидаемым
- для этого есть функция expect, которая позволяет выполнить утверждение
- мы, условно говоря, говорим, что в result мы ожидаем - true
```ts
expect(result).toBe(true);
```

```ts
// game.test.ts

import { isArtistAnswerCorrect } from './game';
import { makeFakeArtistQuestion } from './utils/mocks';

describe('Function: isArtistAnswerCorrect', () => {
  it('should return "true" when answer is correct', () => {
    // Arrange
    const mockArtiestQuestion = makeFakeArtistQuestion();
    const { artist: correctAnswer } = mockArtiestQuestion.song;

    // Act
    const result = isArtistAnswerCorrect(mockArtiestQuestion, correctAnswer);

    // Assert
    expect(result).toBe(true);
  });
});
```

- тест готов, теперь его можно запустить

- в терминале ввести команду npm run test
- ответ от терминала покажет, что был найден один тест, и он был пройден

- также можно установить специальное расширение vitest, которое позволяет запускать и debug тесты
- после установки в sidebar появится отдельная иконка и там будут перечислены все модули, которые содержат тесты и мы сможем их запустить